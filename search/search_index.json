{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#introduction","title":"Introduction","text":"<p>PyBrook - a real-time cloud computing framework for the Internet of Things. PyBrook enables users to define complex data processing models declaratively using the Python programming language. The framework also provides a generic web interface that presents the collected data in real-time.</p> <p>PyBrook aims to make the development of real-time data processing services as easy as possible by utilising powerful  mechanisms of the Python programming language and modern concepts like hot-reloading or deploying software in Linux Containers.</p> <p>A simple <code>docker-compose up</code> is enough to start playing with the framework.</p>"},{"location":"index.html#run-demo-with-docker","title":"Run demo with Docker","text":"<p>It is recommended to use <code>docker compose</code> for learning (you can use the <code>docker-compose.yml</code> from the project repository:</p> <pre><code>docker compose up\n</code></pre> <p>This command will start all the services, including Redis with Redis Gears enabled.</p> <p>The following services will be available:</p> <ul> <li>OpenAPI docs (ReDoc): http://localhost:8000/redoc </li> <li>OpenAPI docs (Swagger UI): http://localhost:8000/docs </li> <li>PyBrook frontend: http://localhost:8000/panel </li> <li>Locust panel for load testing: http://localhost:8089</li> </ul> <p>You should probably visit the Locust panel first and start sending some reports.</p>"},{"location":"index.html#using-your-own-model","title":"Using your own model","text":"<p>The configured model is <code>pybrook.examples.demo</code>, but replacing it with your own is very easy. First, you have to save your custom model somewhere.  For now, you can just copy the source of <code>pybrook.examples.demo</code> (attached below) and save it as <code>mymodel.py</code> in your working directory.</p> Source of <code>pybrook.examples.demo</code> <pre><code>from datetime import datetime\nfrom math import atan2, degrees\nfrom typing import Optional, Sequence\n\nfrom pybrook.models import (\n    InReport,\n    OutReport,\n    PyBrook,\n    ReportField,\n    dependency,\n    historical_dependency,\n)\n\nbrook = PyBrook('redis://localhost')\napp = brook.app\n\n\n@brook.input('ztm-report', id_field='vehicle_number')\nclass ZTMReport(InReport):\n    vehicle_number: int\n    time: datetime\n    lat: float\n    lon: float\n    brigade: str\n    line: str\n\n\n@brook.output('location-report')\nclass LocationReport(OutReport):\n    vehicle_number = ReportField(ZTMReport.vehicle_number)\n    lat = ReportField(ZTMReport.lat)\n    lon = ReportField(ZTMReport.lon)\n    line = ReportField(ZTMReport.line)\n    time = ReportField(ZTMReport.time)\n    brigade = ReportField(ZTMReport.brigade)\n\n\n@brook.artificial_field()\ndef direction(lat_history: Sequence[float] = historical_dependency(\n    ZTMReport.lat, history_length=1),\n                    lon_history: Sequence[float] = historical_dependency(\n                        ZTMReport.lon, history_length=1),\n                    lat: float = dependency(ZTMReport.lat),\n                    lon: float = dependency(ZTMReport.lon)) -&gt; Optional[float]:\n    prev_lat, = lat_history\n    prev_lon, = lon_history\n    if prev_lat and prev_lon:\n        return degrees(atan2(lon - prev_lon, lat - prev_lat))\n    else:\n        return None\n\n\n@brook.output('direction-report')\nclass DirectionReport(OutReport):\n    direction = ReportField(direction)\n\n\n@brook.artificial_field()\nasync def counter(prev_values: Sequence[int] = historical_dependency(\n    'counter', history_length=1),\n                  time: datetime = dependency(ZTMReport.time)) -&gt; int:\n    prev_value, = prev_values\n    if prev_value is None:\n        prev_value = -1\n    prev_value += 1\n    return prev_value\n\n\n@brook.output('counter-report')\nclass CounterReport(OutReport):\n    counter = ReportField(counter)\n\n\nbrook.set_meta(latitude_field=LocationReport.lat,\n               longitude_field=LocationReport.lon,\n               time_field=LocationReport.time,\n               group_field=LocationReport.line,\n               direction_field=DirectionReport.direction)\n\nif __name__ == '__main__':\n    brook.run()\n</code></pre> <p>After creating <code>mymodel.py</code>, you should add it to the <code>api</code> and <code>worker</code> containers, using a Docker volume. To make PyBrook use <code>mymodel</code> instead of <code>pybrook.examples.demo</code>, you should also alter the arguments passed to <code>gunicorn</code> and <code>pybrook</code>.  You can simply add it to the default <code>docker-compose.yml</code>:</p> <pre><code>services:\n  api:\n    image: pybrook:latest\n    build:\n      context: .\n    environment:\n      REDIS_URL: redis://redis\n    ports:\n      - 8000:8000\n    volumes:\n      - ./mymodel.py:/src/mymodel.py\n    command: gunicorn mymodel:app \n          -w 4 -k uvicorn.workers.UvicornWorker \n          -b 0.0.0.0:8000\n  worker:\n    image: pybrook:latest\n    depends_on:\n      - api\n    environment:\n      REDIS_URL: redis://redis\n      DEFAULT_WORKERS: 8\n    volumes:\n      - ./mymodel.py:/src/mymodel.py\n    command: pybrook mymodel:brook\n  locust:\n    image: pybrook:latest\n    depends_on:\n      - api\n    ports:\n      - 8089:8089\n    command: locust -H http://api:8000\n  redis:\n    image: pybrook/redis:latest\n</code></pre> <p>Then run <code>docker-compose up --build</code> again, to start PyBrook - this time using your own model.</p>"},{"location":"index.html#setup-development","title":"Setup &amp; Development","text":"<p>You can install the PyBrook from PyPi using <code>pip</code>:</p> <pre><code>pip install pybrook\n</code></pre>"},{"location":"index.html#running-all-services-manually-without-docker","title":"Running all services manually, without Docker","text":"<p>To run the <code>pybrook.examples.demo</code> model, you have to start all the required services manually:</p> <pre><code># Redis + the PyBrook Redis module\ndocker run --net=host -d pybrook/redis:latest\n# HTTP API based on pybrook.examples.demo - uvicorn\nuvicorn pybrook.examples.demo:app --reload  \n# PyBrook workers based on pybrook.examples.demo \npybrook pybrook.examples.demo:brook \n# Locust - load testing\nlocust -H http://localhost:8000\n</code></pre>"},{"location":"index.html#contributing","title":"Contributing","text":"<p>PyBrook uses poetry for dependency management. To install all its development dependencies, simply run this command:</p> <pre><code>poetry install\n</code></pre>"},{"location":"index.html#tests","title":"Tests","text":"<pre><code>make test\n</code></pre>"},{"location":"index.html#code-quality","title":"Code quality","text":"<p>The source code of PyBrook is formatted using yapf and isort. To run them with the correct settings, use the following command:</p> <pre><code>make format\n</code></pre> <p>PyBrook uses <code>mypy</code> for type checking and <code>flake8</code> for linting. Use the following command to run them with the appropriate settings:</p> <pre><code>make lint\n</code></pre>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>pybrook<ul> <li>__main__</li> <li>config</li> <li>consumers<ul> <li>base</li> <li>field_generator</li> <li>worker</li> </ul> </li> <li>encoding</li> <li>examples<ul> <li>demo</li> <li>ztm</li> </ul> </li> <li>models</li> <li>redis_plugin_integration</li> <li>schemas</li> </ul> </li> </ul>"},{"location":"reference/pybrook/__init__.html","title":"<code>__init__</code>","text":"<p>This module contains package metadata</p>"},{"location":"reference/pybrook/__init__.html#pybrook.VERSION","title":"<code>VERSION = importlib_metadata.version(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/__main__.html","title":"<code>pybrook.__main__</code>","text":"<p>PyBrook CLI entrypoint.</p>"},{"location":"reference/pybrook/__main__.html#pybrook.__main__.ModelChangeEventHandler","title":"<code>ModelChangeEventHandler</code>","text":"<p>               Bases: <code>FileSystemEventHandler</code></p> <p>Handles model hot-reloading.</p> Source code in <code>pybrook/__main__.py</code> <pre><code>class ModelChangeEventHandler(FileSystemEventHandler):\n    \"\"\"\n    Handles model hot-reloading.\n    \"\"\"\n\n    def __init__(self, brook: PyBrook):\n        \"\"\"\n\n        Args:\n            brook: A PyBrook instance.\n        \"\"\"\n        self.brook = brook\n        self.modified = False\n\n    def on_modified(self, event: Union[DirModifiedEvent, FileModifiedEvent]):\n        \"\"\"\n\n        Args:\n            event: Event representing file/directory modification.\n        \"\"\"\n        logger.info(\"File change detected, reloading...\")\n        self.modified = True\n        self.brook.terminate()\n</code></pre>"},{"location":"reference/pybrook/__main__.html#pybrook.__main__.ModelChangeEventHandler.brook","title":"<code>brook = brook</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/__main__.html#pybrook.__main__.ModelChangeEventHandler.modified","title":"<code>modified = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/__main__.html#pybrook.__main__.ModelChangeEventHandler.__init__","title":"<code>__init__(brook)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>brook</code> <code>PyBrook</code> <p>A PyBrook instance.</p> required Source code in <code>pybrook/__main__.py</code> <pre><code>def __init__(self, brook: PyBrook):\n    \"\"\"\n\n    Args:\n        brook: A PyBrook instance.\n    \"\"\"\n    self.brook = brook\n    self.modified = False\n</code></pre>"},{"location":"reference/pybrook/__main__.html#pybrook.__main__.ModelChangeEventHandler.on_modified","title":"<code>on_modified(event)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>event</code> <code>Union[DirModifiedEvent, FileModifiedEvent]</code> <p>Event representing file/directory modification.</p> required Source code in <code>pybrook/__main__.py</code> <pre><code>def on_modified(self, event: Union[DirModifiedEvent, FileModifiedEvent]):\n    \"\"\"\n\n    Args:\n        event: Event representing file/directory modification.\n    \"\"\"\n    logger.info(\"File change detected, reloading...\")\n    self.modified = True\n    self.brook.terminate()\n</code></pre>"},{"location":"reference/pybrook/__main__.html#pybrook.__main__.add_consumer_args","title":"<code>add_consumer_args(parser, consumers)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The main argument parser.</p> required <code>consumers</code> <code>list[BaseStreamConsumer]</code> <p>List of consumers to generate CLI options for.</p> required <p>Returns:</p> Type Description <code>dict[str, ConsumerConfig]</code> <p>A dictionary of consumer configs filled with defaults.</p> <code>dict[str, ConsumerConfig]</code> <p>Consumer group names are used as keys.</p> Source code in <code>pybrook/__main__.py</code> <pre><code>def add_consumer_args(\n    parser: argparse.ArgumentParser, consumers: list[BaseStreamConsumer]\n) -&gt; dict[str, ConsumerConfig]:\n    \"\"\"\n\n    Args:\n        parser: The main argument parser.\n        consumers: List of consumers to generate CLI options for.\n\n    Returns:\n        A dictionary of consumer configs filled with defaults.\n        Consumer group names are used as keys.\n\n    \"\"\"\n    workers_config = {}\n    for c in consumers:\n        consumer_config = ConsumerConfig()\n        with suppress(ArgumentError):\n            parser.add_argument(\n                f\"--{c.consumer_group_name}-workers\",\n                type=int,\n                help=\"(default: %(default)s)\",  # noqa: WPS323\n                default=consumer_config.workers,\n            )\n        workers_config[c.consumer_group_name] = consumer_config\n    return workers_config\n</code></pre>"},{"location":"reference/pybrook/__main__.html#pybrook.__main__.main","title":"<code>main()</code>","text":"<p>CLI Entrypoint.</p> <p>Starts PyBrook workers.</p> <p>Examples:</p> <pre><code>```bash\n\u276f pybrook pybrook.examples.demo:brook --help\nusage: pybrook [-h]\n       [--location-report:dr-workers LOCATION_REPORT:DR_WORKERS]\n       [--direction-report:dr-workers DIRECTION_REPORT:DR_WORKERS]\n       [--brigade-report:dr-workers BRIGADE_REPORT:DR_WORKERS]\n       [--direction:dr-workers DIRECTION:DR_WORKERS]\n       [--direction:fg-workers DIRECTION:FG_WORKERS]\n       APP\n\npositional arguments:\n  APP\n\noptions:\n  -h, --help\n  --location-report:dr-workers LOCATION_REPORT:DR_WORKERS\n                        (default: 4)\n  --direction-report:dr-workers DIRECTION_REPORT:DR_WORKERS\n                        (default: 4)\n  --brigade-report:dr-workers BRIGADE_REPORT:DR_WORKERS\n                        (default: 4)\n  --direction:dr-workers DIRECTION:DR_WORKERS\n                        (default: 4)\n  --direction:fg-workers DIRECTION:FG_WORKERS\n                        (default: 4)\n\n```\n</code></pre> Source code in <code>pybrook/__main__.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    CLI Entrypoint.\n\n    Starts PyBrook workers.\n\n    Examples:\n\n        ```bash\n        \u276f pybrook pybrook.examples.demo:brook --help\n        usage: pybrook [-h]\n               [--location-report:dr-workers LOCATION_REPORT:DR_WORKERS]\n               [--direction-report:dr-workers DIRECTION_REPORT:DR_WORKERS]\n               [--brigade-report:dr-workers BRIGADE_REPORT:DR_WORKERS]\n               [--direction:dr-workers DIRECTION:DR_WORKERS]\n               [--direction:fg-workers DIRECTION:FG_WORKERS]\n               APP\n\n        positional arguments:\n          APP\n\n        options:\n          -h, --help\n          --location-report:dr-workers LOCATION_REPORT:DR_WORKERS\n                                (default: 4)\n          --direction-report:dr-workers DIRECTION_REPORT:DR_WORKERS\n                                (default: 4)\n          --brigade-report:dr-workers BRIGADE_REPORT:DR_WORKERS\n                                (default: 4)\n          --direction:dr-workers DIRECTION:DR_WORKERS\n                                (default: 4)\n          --direction:fg-workers DIRECTION:FG_WORKERS\n                                (default: 4)\n\n        ```\n    \"\"\"\n\n    parser = argparse.ArgumentParser(add_help=False)\n    parser.add_argument(\"-h\", \"--help\", action=\"store_true\")\n    parser.add_argument(\"APP\", nargs=1)\n    args: argparse.Namespace\n    unknown: list[str]\n    args, unknown = parser.parse_known_args()\n    app_arg = args.APP[-1].split(\":\") if args.APP else None\n    if not app_arg and args.help:\n        parser.print_help()\n        return\n    model_module = import_module(app_arg[0])\n    modified = True\n    while modified:\n        brook: PyBrook = (\n            getattr(model_module, app_arg[1])\n            if len(app_arg) &gt; 1\n            else model_module.brook\n        )\n        brook.process_model()\n        workers_config = add_consumer_args(parser, brook.consumers)\n        args = parser.parse_args()\n        if args.help:\n            parser.print_help()\n            return\n        update_workers_config(args, workers_config)\n        handler = ModelChangeEventHandler(brook)\n        observer = Observer()\n        observer.schedule(handler, model_module.__file__)  # noqa: WPS609\n        observer.start()\n        brook.run(config=workers_config)\n        observer.stop()\n        observer.join()\n        reload(model_module)\n        modified = handler.modified\n</code></pre>"},{"location":"reference/pybrook/__main__.html#pybrook.__main__.update_workers_config","title":"<code>update_workers_config(args, workers_config)</code>","text":"<p>Updates <code>workers_config</code> with settings loaded from argparse arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>An argparse <code>Namespace</code></p> required <code>workers_config</code> <code>dict[str, ConsumerConfig]</code> <p>A dictionary of consumer configs to update using settings loaded from the <code>args</code> argument.</p> required <p>Returns:</p> Source code in <code>pybrook/__main__.py</code> <pre><code>def update_workers_config(\n    args: argparse.Namespace, workers_config: dict[str, ConsumerConfig]\n):\n    \"\"\"\n    Updates `workers_config` with settings loaded from argparse arguments.\n\n    Args:\n        args: An argparse `Namespace`\n        workers_config:  A dictionary of\n            consumer configs to update using\n            settings loaded from the `args` argument.\n\n    Returns:\n\n    \"\"\"\n    for c in workers_config:\n        for arg in (\"workers\",):\n            arg_name: str = c.replace(\"-\", \"_\") + \"_\" + arg\n            setattr(workers_config[c], arg, getattr(args, arg_name))\n</code></pre>"},{"location":"reference/pybrook/config.html","title":"<code>pybrook.config</code>","text":""},{"location":"reference/pybrook/config.html#pybrook.config.ARTIFICIAL_NAMESPACE","title":"<code>ARTIFICIAL_NAMESPACE = config('ARTIFICIAL_NAMESPACE', str, default='artificial')</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/config.html#pybrook.config.DEFAULT_WORKERS","title":"<code>DEFAULT_WORKERS = config('DEFAULT_WORKERS', int, default=4)</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/config.html#pybrook.config.MSG_ID_FIELD","title":"<code>MSG_ID_FIELD = '@pb@msg_id'</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/config.html#pybrook.config.REDIS_URI","title":"<code>REDIS_URI = config('REDIS_URI', str, default='redis://localhost')</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/config.html#pybrook.config.SPECIAL_CHAR","title":"<code>SPECIAL_CHAR = config('SPECIAL_CHAR', str, default=':')</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/config.html#pybrook.config.WEBSOCKET_PING_INTERVAL","title":"<code>WEBSOCKET_PING_INTERVAL = config('WEBSOCKET_PING_INTERVAL', int, default=30)</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/config.html#pybrook.config.WEBSOCKET_WAIT_TIME","title":"<code>WEBSOCKET_WAIT_TIME = config('WEBSOCKET_WAIT_TIME', float, default=0.01)</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/config.html#pybrook.config.WEBSOCKET_XREAD_BLOCK","title":"<code>WEBSOCKET_XREAD_BLOCK = config('WEBSOCKET_XREAD_BLOCK', int, default=100)</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/config.html#pybrook.config.WEBSOCKET_XREAD_COUNT","title":"<code>WEBSOCKET_XREAD_COUNT = config('WEBSOCKET_XREAD_COUNT', int, default=1000)</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/config.html#pybrook.config.config","title":"<code>config = Config()</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/encoding.html","title":"<code>pybrook.encoding</code>","text":""},{"location":"reference/pybrook/encoding.html#pybrook.encoding.decode_stream_message","title":"<code>decode_stream_message(data)</code>","text":"Source code in <code>pybrook/encoding.py</code> <pre><code>def decode_stream_message(data: dict[str, str]):\n    return {k: decode_value(v) for k, v in data.items()}\n</code></pre>"},{"location":"reference/pybrook/encoding.html#pybrook.encoding.decode_value","title":"<code>decode_value(v)</code>","text":"Source code in <code>pybrook/encoding.py</code> <pre><code>def decode_value(v: Any):\n    return orjson.loads(v)\n</code></pre>"},{"location":"reference/pybrook/encoding.html#pybrook.encoding.encode_stream_message","title":"<code>encode_stream_message(data)</code>","text":"Source code in <code>pybrook/encoding.py</code> <pre><code>def encode_stream_message(data: dict[str, Any]):\n    return {k: encode_value(v) for k, v in data.items()}\n</code></pre>"},{"location":"reference/pybrook/encoding.html#pybrook.encoding.encode_value","title":"<code>encode_value(v)</code>","text":"Source code in <code>pybrook/encoding.py</code> <pre><code>def encode_value(v: Any):\n    return orjson.dumps(v)\n</code></pre>"},{"location":"reference/pybrook/models.html","title":"<code>pybrook.models</code>","text":"<p>This module is responsible for parsing report processing models.</p> <p>It is the core of PyBrook.</p>"},{"location":"reference/pybrook/models.html#pybrook.models.DTYPE","title":"<code>DTYPE = TypeVar('DTYPE')</code>  <code>module-attribute</code>","text":"<p>A TypeVar used by dependency and historal_dependency, enable mypy to detect issues with dependency types.</p>"},{"location":"reference/pybrook/models.html#pybrook.models.DependencySource","title":"<code>DependencySource = Union['SourceField', type[aioredis.Redis], type[redis.Redis]]</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.TI","title":"<code>TI = TypeVar('TI', bound=type[InReport])</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.TO","title":"<code>TO = TypeVar('TO', bound=type[OutReport])</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.TOPT","title":"<code>TOPT = TypeVar('TOPT')</code>  <code>module-attribute</code>","text":"<p>A TypeVar used by OptionsMixin, to define the type of the Options.</p>"},{"location":"reference/pybrook/models.html#pybrook.models.ArtificialField","title":"<code>ArtificialField</code>","text":"<p>               Bases: <code>SourceField</code>, <code>Registrable</code>, <code>ConsumerGenerator</code></p> Source code in <code>pybrook/models.py</code> <pre><code>class ArtificialField(SourceField, Registrable, ConsumerGenerator):\n    def __init__(self, calculate: Callable, name: Optional[str] = None):\n        annotations = get_type_hints(calculate)\n        try:\n            value_type = annotations.pop(\"return\")\n        except KeyError as e:\n            raise ValueError(\n                f\"Please specify return value for {calculate.__name__}\"\n            ) from e\n        super().__init__(field_name=(name or calculate.__name__), value_type=value_type)\n        self.args: inspect.Signature = inspect.signature(calculate)\n        self.is_coro: bool = inspect.iscoroutinefunction(calculate)\n        self.dependencies: dict[str, Dependency] = {\n            arg_name: arg.default for arg_name, arg in self.args.parameters.items()\n        }\n        all_defaults_are_deps = all(\n            isinstance(d, Dependency) for k, d in self.dependencies.items()\n        )\n        if not all_defaults_are_deps:\n            raise RuntimeError(\n                f'Artificial field \"{self.field_name}\" has default values'\n                f\" which do not subclass Dependency.\"\n            )\n        self.calculate = calculate\n\n    def __call__(self, *args, **kwargs):\n        return self.calculate(*args, **kwargs)\n\n    @property\n    def regular_dependencies(self) -&gt; dict[str, Dependency]:\n        return {\n            k: d\n            for k, d in self.dependencies.items()\n            if not isinstance(d, HistoricalDependency)\n        }\n\n    @property\n    def historical_dependencies(self) -&gt; dict[str, HistoricalDependency]:\n        return {\n            k: d\n            for k, d in self.dependencies.items()\n            if isinstance(d, HistoricalDependency)\n        }\n\n    def on_registered(self, model: \"PyBrook\"):\n        for dep in self.dependencies.values():\n            dep.on_registered(model)\n\n    def gen_consumers(self, model: \"PyBrook\"):  # type: ignore\n        inputs: dict[str, redis_plugin.Dependency] = {}\n        stream_key: str\n        dep: redis_plugin.Dependency\n        for field_name, field in self.regular_dependencies.items():\n            stream_key = field.src_field.stream_name\n            dep = inputs.setdefault(\n                stream_key, redis_plugin.Dependency(stream_key=stream_key)\n            )\n            dep.fields.append(\n                redis_plugin.DependencyField(\n                    src=field.src_field.field_name, dst=field_name\n                )\n            )\n        for field_name, field in self.historical_dependencies.items():\n            stream_key = field.src_field.stream_name\n            dep = inputs.setdefault(\n                stream_key, redis_plugin.Dependency(stream_key=stream_key)\n            )\n            dep.fields.append(\n                redis_plugin.HistoricalDependencyField(\n                    src=field.src_field.field_name,\n                    dst=field_name,\n                    history_len=field.history_length,\n                )\n            )\n        arguments_stream_key = f\"{SPECIAL_CHAR}{self.field_name}\" f\"{SPECIAL_CHAR}args\"\n        model.add_dependency_resolver(\n            redis_plugin.DependencyResolver(\n                output_stream_key=arguments_stream_key, inputs=list(inputs.values())\n            )\n        )\n\n        field_generator_deps = [\n            BaseFieldGenerator.Dep(name=dep_name, value_type=dep.value_type)\n            for dep_name, dep in self.dependencies.items()\n            if dep.src_field\n        ]\n\n        generator_class: type[BaseFieldGenerator] = (\n            AsyncFieldGenerator if self.is_coro else SyncFieldGenerator\n        )\n\n        field_generator = generator_class(\n            redis_url=model.redis_url,\n            dependency_stream=arguments_stream_key,\n            field_name=self.field_name,\n            generator=self.calculate,\n            dependencies=field_generator_deps,\n            redis_deps=[\n                key\n                for key, dep in self.dependencies.items()\n                if (dep.is_aioredis and self.is_coro) or dep.is_redis\n            ],\n        )\n\n        model.add_consumer(field_generator)\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.ArtificialField.args","title":"<code>args: inspect.Signature = inspect.signature(calculate)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.ArtificialField.calculate","title":"<code>calculate = calculate</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.ArtificialField.dependencies","title":"<code>dependencies: dict[str, Dependency] = {arg_name: arg.defaultfor (arg_name, arg) in self.args.parameters.items()}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.ArtificialField.historical_dependencies","title":"<code>historical_dependencies: dict[str, HistoricalDependency]</code>  <code>property</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.ArtificialField.is_coro","title":"<code>is_coro: bool = inspect.iscoroutinefunction(calculate)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.ArtificialField.regular_dependencies","title":"<code>regular_dependencies: dict[str, Dependency]</code>  <code>property</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.ArtificialField.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __call__(self, *args, **kwargs):\n    return self.calculate(*args, **kwargs)\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.ArtificialField.__init__","title":"<code>__init__(calculate, name=None)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __init__(self, calculate: Callable, name: Optional[str] = None):\n    annotations = get_type_hints(calculate)\n    try:\n        value_type = annotations.pop(\"return\")\n    except KeyError as e:\n        raise ValueError(\n            f\"Please specify return value for {calculate.__name__}\"\n        ) from e\n    super().__init__(field_name=(name or calculate.__name__), value_type=value_type)\n    self.args: inspect.Signature = inspect.signature(calculate)\n    self.is_coro: bool = inspect.iscoroutinefunction(calculate)\n    self.dependencies: dict[str, Dependency] = {\n        arg_name: arg.default for arg_name, arg in self.args.parameters.items()\n    }\n    all_defaults_are_deps = all(\n        isinstance(d, Dependency) for k, d in self.dependencies.items()\n    )\n    if not all_defaults_are_deps:\n        raise RuntimeError(\n            f'Artificial field \"{self.field_name}\" has default values'\n            f\" which do not subclass Dependency.\"\n        )\n    self.calculate = calculate\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.ArtificialField.gen_consumers","title":"<code>gen_consumers(model)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def gen_consumers(self, model: \"PyBrook\"):  # type: ignore\n    inputs: dict[str, redis_plugin.Dependency] = {}\n    stream_key: str\n    dep: redis_plugin.Dependency\n    for field_name, field in self.regular_dependencies.items():\n        stream_key = field.src_field.stream_name\n        dep = inputs.setdefault(\n            stream_key, redis_plugin.Dependency(stream_key=stream_key)\n        )\n        dep.fields.append(\n            redis_plugin.DependencyField(\n                src=field.src_field.field_name, dst=field_name\n            )\n        )\n    for field_name, field in self.historical_dependencies.items():\n        stream_key = field.src_field.stream_name\n        dep = inputs.setdefault(\n            stream_key, redis_plugin.Dependency(stream_key=stream_key)\n        )\n        dep.fields.append(\n            redis_plugin.HistoricalDependencyField(\n                src=field.src_field.field_name,\n                dst=field_name,\n                history_len=field.history_length,\n            )\n        )\n    arguments_stream_key = f\"{SPECIAL_CHAR}{self.field_name}\" f\"{SPECIAL_CHAR}args\"\n    model.add_dependency_resolver(\n        redis_plugin.DependencyResolver(\n            output_stream_key=arguments_stream_key, inputs=list(inputs.values())\n        )\n    )\n\n    field_generator_deps = [\n        BaseFieldGenerator.Dep(name=dep_name, value_type=dep.value_type)\n        for dep_name, dep in self.dependencies.items()\n        if dep.src_field\n    ]\n\n    generator_class: type[BaseFieldGenerator] = (\n        AsyncFieldGenerator if self.is_coro else SyncFieldGenerator\n    )\n\n    field_generator = generator_class(\n        redis_url=model.redis_url,\n        dependency_stream=arguments_stream_key,\n        field_name=self.field_name,\n        generator=self.calculate,\n        dependencies=field_generator_deps,\n        redis_deps=[\n            key\n            for key, dep in self.dependencies.items()\n            if (dep.is_aioredis and self.is_coro) or dep.is_redis\n        ],\n    )\n\n    model.add_consumer(field_generator)\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.ArtificialField.on_registered","title":"<code>on_registered(model)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def on_registered(self, model: \"PyBrook\"):\n    for dep in self.dependencies.values():\n        dep.on_registered(model)\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.ConsumerGenerator","title":"<code>ConsumerGenerator</code>","text":"<p>An interface describing objects that can generate stream consumers/producers.</p> Source code in <code>pybrook/models.py</code> <pre><code>class ConsumerGenerator:\n    \"\"\"\n    An interface describing objects that can generate stream consumers/producers.\n    \"\"\"\n\n    @classmethod\n    def gen_consumers(cls, model: \"PyBrook\"):\n        \"\"\"\n        Implementations of this method should add\n        consumers to the [PyBrook][pybrook.models.PyBrook]\n        instance passed as `model`.\n\n        Args:\n            model: The PyBrook instance processed.\n\n        Raises:\n            NotImplementedError: When used directly.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.ConsumerGenerator.gen_consumers","title":"<code>gen_consumers(model)</code>  <code>classmethod</code>","text":"<p>Implementations of this method should add consumers to the PyBrook instance passed as <code>model</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>PyBrook</code> <p>The PyBrook instance processed.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>When used directly.</p> Source code in <code>pybrook/models.py</code> <pre><code>@classmethod\ndef gen_consumers(cls, model: \"PyBrook\"):\n    \"\"\"\n    Implementations of this method should add\n    consumers to the [PyBrook][pybrook.models.PyBrook]\n    instance passed as `model`.\n\n    Args:\n        model: The PyBrook instance processed.\n\n    Raises:\n        NotImplementedError: When used directly.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.Dependency","title":"<code>Dependency</code>","text":"<p>               Bases: <code>Registrable</code></p> <p>This class represents a dependency of an ArtificialField.</p> <p>In theory, it can be used directly as an argument default of a calculation function, but it is recommended to use the dependency callable, which provides mypy compatibility instead.</p> Source code in <code>pybrook/models.py</code> <pre><code>class Dependency(Registrable):\n    \"\"\"\n    This class represents a\n    dependency of an [ArtificialField][pybrook.models.ArtificialField].\n\n    In theory, it can be used directly as\n    an argument default of a calculation function,\n    but it is recommended to use\n    the [dependency][pybrook.models.dependency] callable,\n    which provides mypy compatibility instead.\n    \"\"\"\n\n    def __init__(self, src: DependencySource):\n        \"\"\"\n        See [dependency][pybrook.models.dependency].\n        \"\"\"\n        self.is_aioredis: bool = False\n        self.is_redis: bool = False\n        self._src_field: Union[SourceField, str] = self.validate_source_field(src)\n        self.is_historical = False\n\n    @property\n    def src_field(self) -&gt; \"SourceField\":\n        if isinstance(self._src_field, SourceField):\n            return self._src_field\n        else:\n            raise RuntimeError(\"src_field not initialized via registered\")\n\n    @property\n    def value_type(self):\n        \"\"\"Value type of the source field.\"\"\"\n        return self.src_field.value_type\n\n    def validate_source_field(self, src: DependencySource):\n        self.is_aioredis = type(src) is type and issubclass(  # noqa: WPS516\n            src, aioredis.Redis\n        )\n        self.is_redis = type(src) is type and issubclass(  # noqa: WPS516\n            src, redis.Redis\n        )\n        if isinstance(src, SourceField):\n            return src\n        elif not (self.is_aioredis or self.is_redis):\n            raise ValueError(\n                f\"{src} is not an instance of SourceField or a Redis class\"\n            )\n\n    def on_registered(self, model: \"PyBrook\"):\n        \"\"\"\n        Artificial fields can be evaluated lazily, that's why this is required.\n\n        Args:\n            model: model at which the field has been registered\n\n        Raises:\n            ValueError: when src_field is not an ArtificialField instance\n        \"\"\"\n        if isinstance(self._src_field, str):\n            try:\n                self._src_field = model.artificial_fields[self._src_field]\n            except KeyError as e:\n                raise ValueError(\n                    f\"Lazy evaluation is only supported for artificial fields,\"\n                    f\" and {self.src_field} is not one of these.\"\n                ) from e\n\n    def __repr__(self):\n        if self.is_aioredis:\n            return \"&lt;Dependency aioredis&gt;\"\n        if self.is_redis:\n            return \"&lt;Dependency redis&gt;\"\n        return f\"&lt;Dependency src_field={self.src_field}&gt;\"\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.Dependency._src_field","title":"<code>_src_field: Union[SourceField, str] = self.validate_source_field(src)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.Dependency.is_aioredis","title":"<code>is_aioredis: bool = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.Dependency.is_historical","title":"<code>is_historical = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.Dependency.is_redis","title":"<code>is_redis: bool = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.Dependency.src_field","title":"<code>src_field: SourceField</code>  <code>property</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.Dependency.value_type","title":"<code>value_type</code>  <code>property</code>","text":"<p>Value type of the source field.</p>"},{"location":"reference/pybrook/models.html#pybrook.models.Dependency.__init__","title":"<code>__init__(src)</code>","text":"<p>See dependency.</p> Source code in <code>pybrook/models.py</code> <pre><code>def __init__(self, src: DependencySource):\n    \"\"\"\n    See [dependency][pybrook.models.dependency].\n    \"\"\"\n    self.is_aioredis: bool = False\n    self.is_redis: bool = False\n    self._src_field: Union[SourceField, str] = self.validate_source_field(src)\n    self.is_historical = False\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.Dependency.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __repr__(self):\n    if self.is_aioredis:\n        return \"&lt;Dependency aioredis&gt;\"\n    if self.is_redis:\n        return \"&lt;Dependency redis&gt;\"\n    return f\"&lt;Dependency src_field={self.src_field}&gt;\"\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.Dependency.on_registered","title":"<code>on_registered(model)</code>","text":"<p>Artificial fields can be evaluated lazily, that's why this is required.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>PyBrook</code> <p>model at which the field has been registered</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>when src_field is not an ArtificialField instance</p> Source code in <code>pybrook/models.py</code> <pre><code>def on_registered(self, model: \"PyBrook\"):\n    \"\"\"\n    Artificial fields can be evaluated lazily, that's why this is required.\n\n    Args:\n        model: model at which the field has been registered\n\n    Raises:\n        ValueError: when src_field is not an ArtificialField instance\n    \"\"\"\n    if isinstance(self._src_field, str):\n        try:\n            self._src_field = model.artificial_fields[self._src_field]\n        except KeyError as e:\n            raise ValueError(\n                f\"Lazy evaluation is only supported for artificial fields,\"\n                f\" and {self.src_field} is not one of these.\"\n            ) from e\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.Dependency.validate_source_field","title":"<code>validate_source_field(src)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def validate_source_field(self, src: DependencySource):\n    self.is_aioredis = type(src) is type and issubclass(  # noqa: WPS516\n        src, aioredis.Redis\n    )\n    self.is_redis = type(src) is type and issubclass(  # noqa: WPS516\n        src, redis.Redis\n    )\n    if isinstance(src, SourceField):\n        return src\n    elif not (self.is_aioredis or self.is_redis):\n        raise ValueError(\n            f\"{src} is not an instance of SourceField or a Redis class\"\n        )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.HistoricalDependency","title":"<code>HistoricalDependency</code>","text":"<p>               Bases: <code>Dependency</code></p> <p>This class represents a historical dependency of an ArtificialField.</p> <p>In theory, it can be used directly as an argument default of a calculation function, but it is recommended to use the historical_dependency callable, which provides mypy compatibility instead.</p> Source code in <code>pybrook/models.py</code> <pre><code>class HistoricalDependency(Dependency):\n    \"\"\"\n    This class represents a historical\n    dependency of an [ArtificialField][pybrook.models.ArtificialField].\n\n    In theory, it can be used directly\n    as an argument default of a calculation function,\n    but it is recommended to use the\n    [historical_dependency][pybrook.models.historical_dependency]\n    callable, which provides mypy compatibility instead.\n    \"\"\"\n\n    def __init__(self, src_field: Union[\"SourceField\", str], history_length: int):\n        \"\"\"\n        See [historical_dependency][pybrook.models.historical_dependency].\n        \"\"\"\n        super().__init__(src_field)  # type: ignore\n        self.history_length = history_length\n        self.is_historical = True\n\n    @property\n    def value_type(self):\n        return list[Union[self.src_field.value_type, None]]\n\n    def validate_source_field(self, src: DependencySource):\n        if isinstance(src, str):\n            return src\n        return super().validate_source_field(src)\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.HistoricalDependency.history_length","title":"<code>history_length = history_length</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.HistoricalDependency.is_historical","title":"<code>is_historical = True</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.HistoricalDependency.value_type","title":"<code>value_type</code>  <code>property</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.HistoricalDependency.__init__","title":"<code>__init__(src_field, history_length)</code>","text":"<p>See historical_dependency.</p> Source code in <code>pybrook/models.py</code> <pre><code>def __init__(self, src_field: Union[\"SourceField\", str], history_length: int):\n    \"\"\"\n    See [historical_dependency][pybrook.models.historical_dependency].\n    \"\"\"\n    super().__init__(src_field)  # type: ignore\n    self.history_length = history_length\n    self.is_historical = True\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.HistoricalDependency.validate_source_field","title":"<code>validate_source_field(src)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def validate_source_field(self, src: DependencySource):\n    if isinstance(src, str):\n        return src\n    return super().validate_source_field(src)\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.InReport","title":"<code>InReport</code>","text":"<p>               Bases: <code>ConsumerGenerator</code>, <code>RouteGenerator</code>, <code>BaseModel</code></p> Source code in <code>pybrook/models.py</code> <pre><code>class InReport(\n    ConsumerGenerator, RouteGenerator, pydantic.BaseModel, metaclass=InReportMeta\n):\n    @classmethod\n    def gen_consumers(cls, model: \"PyBrook\"):\n        model.add_input_tagger(\n            redis_plugin.InputTagger(\n                stream_key=cls.pybrook_options.stream_name,\n                obj_id_field=cls.pybrook_options.id_field,\n            )\n        )\n\n    @classmethod\n    def gen_routes(cls, api: \"PyBrookApi\", redis_dep: aioredis.Redis):\n        @api.fastapi.post(\n            f\"/{cls.pybrook_options.name}\", name=f\"Add {cls.pybrook_options.name}\"\n        )\n        async def add_report(\n            report: cls = fastapi.Body(...),  # type: ignore # noqa: B008\n            redis_conn: aioredis.Redis = redis_dep,\n        ):\n            await redis_conn.xadd(\n                cls.pybrook_options.stream_name,\n                encode_stream_message(report.dict(by_alias=False)),  # type: ignore\n            )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.InReport.gen_consumers","title":"<code>gen_consumers(model)</code>  <code>classmethod</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>@classmethod\ndef gen_consumers(cls, model: \"PyBrook\"):\n    model.add_input_tagger(\n        redis_plugin.InputTagger(\n            stream_key=cls.pybrook_options.stream_name,\n            obj_id_field=cls.pybrook_options.id_field,\n        )\n    )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.InReport.gen_routes","title":"<code>gen_routes(api, redis_dep)</code>  <code>classmethod</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>@classmethod\ndef gen_routes(cls, api: \"PyBrookApi\", redis_dep: aioredis.Redis):\n    @api.fastapi.post(\n        f\"/{cls.pybrook_options.name}\", name=f\"Add {cls.pybrook_options.name}\"\n    )\n    async def add_report(\n        report: cls = fastapi.Body(...),  # type: ignore # noqa: B008\n        redis_conn: aioredis.Redis = redis_dep,\n    ):\n        await redis_conn.xadd(\n            cls.pybrook_options.stream_name,\n            encode_stream_message(report.dict(by_alias=False)),  # type: ignore\n        )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.InReportMeta","title":"<code>InReportMeta</code>","text":"<p>               Bases: <code>OptionsMixin[InReportOptions]</code>, <code>ModelMetaclass</code></p> Source code in <code>pybrook/models.py</code> <pre><code>class InReportMeta(OptionsMixin[InReportOptions], pydantic.main.ModelMetaclass):\n    pybrook_options: InReportOptions\n    _input_fields: dict[str, \"InputField\"]\n\n    def __new__(mcs, name, bases, namespace):  # noqa: N804\n        \"\"\"\n        Initialize an InReport subclass by generating a dictionary\n        of [InputFields][pybrook.models.InputField] from the Pydantic fields provided.\n        \"\"\"\n        cls = super().__new__(mcs, name, bases, namespace)  # noqa: WPS117\n        cls._input_fields = {}\n        for prop_name, field in cls.__fields__.items():\n            cls._input_fields[prop_name] = InputField(cls, field)  # type: ignore\n        return cls\n\n    def __getattr__(cls, item: str) -&gt; SourceField:  # noqa: N805\n        \"\"\"This enables the `Model.field` syntax\n        used for references in PyBrook models.\"\"\"\n        if not item.startswith(\"_\") and item in cls._input_fields:\n            return cls._input_fields[item]\n        return super().__getattribute__(item)  # noqa: WPS613\n\n    def _validate_options(cls, options: InReportOptions) -&gt; InReportOptions:  # noqa: N805\n        \"\"\"Validate options set by [PyBrook.input()][pybrook.models.PyBrook.input]\"\"\"\n        try:\n            getattr(cls, options.id_field)\n        except AttributeError:\n            raise RuntimeError(\n                f\"Invalid id_field! {cls.__name__} \"\n                f'has no attribute \"{options.id_field}\".'\n            ) from None\n        return options\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.InReportMeta._input_fields","title":"<code>_input_fields: dict[str, InputField]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.InReportMeta.pybrook_options","title":"<code>pybrook_options: InReportOptions</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.InReportMeta.__getattr__","title":"<code>__getattr__(item)</code>","text":"<p>This enables the <code>Model.field</code> syntax used for references in PyBrook models.</p> Source code in <code>pybrook/models.py</code> <pre><code>def __getattr__(cls, item: str) -&gt; SourceField:  # noqa: N805\n    \"\"\"This enables the `Model.field` syntax\n    used for references in PyBrook models.\"\"\"\n    if not item.startswith(\"_\") and item in cls._input_fields:\n        return cls._input_fields[item]\n    return super().__getattribute__(item)  # noqa: WPS613\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.InReportMeta.__new__","title":"<code>__new__(mcs, name, bases, namespace)</code>","text":"<p>Initialize an InReport subclass by generating a dictionary of InputFields from the Pydantic fields provided.</p> Source code in <code>pybrook/models.py</code> <pre><code>def __new__(mcs, name, bases, namespace):  # noqa: N804\n    \"\"\"\n    Initialize an InReport subclass by generating a dictionary\n    of [InputFields][pybrook.models.InputField] from the Pydantic fields provided.\n    \"\"\"\n    cls = super().__new__(mcs, name, bases, namespace)  # noqa: WPS117\n    cls._input_fields = {}\n    for prop_name, field in cls.__fields__.items():\n        cls._input_fields[prop_name] = InputField(cls, field)  # type: ignore\n    return cls\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.InReportMeta._validate_options","title":"<code>_validate_options(options)</code>","text":"<p>Validate options set by PyBrook.input()</p> Source code in <code>pybrook/models.py</code> <pre><code>def _validate_options(cls, options: InReportOptions) -&gt; InReportOptions:  # noqa: N805\n    \"\"\"Validate options set by [PyBrook.input()][pybrook.models.PyBrook.input]\"\"\"\n    try:\n        getattr(cls, options.id_field)\n    except AttributeError:\n        raise RuntimeError(\n            f\"Invalid id_field! {cls.__name__} \"\n            f'has no attribute \"{options.id_field}\".'\n        ) from None\n    return options\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.InReportOptions","title":"<code>InReportOptions</code>  <code>dataclass</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>@dataclasses.dataclass\nclass InReportOptions:\n    id_field: str\n    name: str\n\n    @property\n    def stream_name(self):\n        return f\"{SPECIAL_CHAR}{self.name}\"\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.InReportOptions.id_field","title":"<code>id_field: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.InReportOptions.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.InReportOptions.stream_name","title":"<code>stream_name</code>  <code>property</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.InReportOptions.__init__","title":"<code>__init__(id_field, name)</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.InputField","title":"<code>InputField</code>","text":"<p>               Bases: <code>SourceField</code></p> Source code in <code>pybrook/models.py</code> <pre><code>class InputField(SourceField):\n    def __init__(\n        self, report_class: type[InReport], pydantic_field: pydantic.fields.ModelField\n    ):\n        super().__init__(\n            pydantic_field.name,\n            value_type=pydantic_field.type_,\n            source_obj=report_class,\n        )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.InputField.__init__","title":"<code>__init__(report_class, pydantic_field)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __init__(\n    self, report_class: type[InReport], pydantic_field: pydantic.fields.ModelField\n):\n    super().__init__(\n        pydantic_field.name,\n        value_type=pydantic_field.type_,\n        source_obj=report_class,\n    )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.OptionsMixin","title":"<code>OptionsMixin</code>","text":"<p>               Bases: <code>Generic[TOPT]</code></p> <p>A mixin used by metaclasses InReportMeta and OutReportMeta.</p> <p>It's responsibility is to add a <code>pybrook_options</code> property, that allows setting &amp; validating passed options.</p> Source code in <code>pybrook/models.py</code> <pre><code>class OptionsMixin(Generic[TOPT]):\n    \"\"\"\n    A mixin used by metaclasses\n    [InReportMeta][pybrook.models.InReportMeta]\n    and [OutReportMeta][pybrook.models.OutReportMeta].\n\n    It's responsibility is to add a `pybrook_options` property,\n    that allows setting &amp; validating passed options.\n    \"\"\"\n\n    @property\n    def pybrook_options(self) -&gt; TOPT:\n        \"\"\"A property containing report options, like `id_field` or `name`.\"\"\"\n        return self._options\n\n    @pybrook_options.setter\n    def pybrook_options(self, options: TOPT):\n        options = self._validate_options(options)\n        self._options = options  # noqa: WPS112\n\n    def _validate_options(self, options: TOPT) -&gt; TOPT:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.OptionsMixin.pybrook_options","title":"<code>pybrook_options: TOPT</code>  <code>property</code> <code>writable</code>","text":"<p>A property containing report options, like <code>id_field</code> or <code>name</code>.</p>"},{"location":"reference/pybrook/models.html#pybrook.models.OptionsMixin._validate_options","title":"<code>_validate_options(options)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def _validate_options(self, options: TOPT) -&gt; TOPT:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.OutReport","title":"<code>OutReport</code>","text":"<p>               Bases: <code>ConsumerGenerator</code>, <code>RouteGenerator</code></p> Source code in <code>pybrook/models.py</code> <pre><code>class OutReport(ConsumerGenerator, RouteGenerator, metaclass=OutReportMeta):\n    @classmethod\n    def gen_routes(  # noqa: WPS217, WPS231\n        cls, api: \"PyBrookApi\", redis_dep: aioredis.Redis\n    ):\n        model_cls = cls.pydantic_model\n\n        @api.fastapi.get(\n            f\"/{cls.pybrook_options.name}\",\n            response_model=model_cls,  # type: ignore\n            name=f\"Retrieve {cls.pybrook_options.name}\",\n        )\n        async def get_report(redis_conn: aioredis.Redis = redis_dep):\n            messages = await redis_conn.xrevrange(\n                cls.pybrook_options.stream_name, count=1\n            )\n            for _msg_id, msg_body in messages:  # noqa: WPS328\n                return model_cls(**decode_stream_message(msg_body))\n            return {}\n\n        @api.fastapi.websocket(f\"/{cls.pybrook_options.name}\")\n        async def read_reports(  # noqa: WPS231\n            websocket: fastapi.WebSocket, redis_conn: aioredis.Redis = redis_dep\n        ):\n            await websocket.accept()\n            last_msg = \"$\"\n            stream_name = cls.pybrook_options.stream_name\n            active = True\n            last_ping = time()\n            while active and api.fastapi.state.socket_active:\n                if time() - last_ping &gt; WEBSOCKET_PING_INTERVAL:\n                    try:\n                        # Check if connection is active\n                        await asyncio.wait_for(\n                            websocket.receive_bytes(), timeout=WEBSOCKET_WAIT_TIME\n                        )\n                    except asyncio.TimeoutError:\n                        ...  # Everything is OK\n                    except (fastapi.WebSocketDisconnect, AssertionError):\n                        active = False\n                    else:\n                        last_ping = time()\n                messages = await redis_conn.xread(\n                    {stream_name: last_msg},\n                    count=WEBSOCKET_XREAD_COUNT,\n                    block=WEBSOCKET_XREAD_BLOCK,\n                )\n                if messages:\n                    # Wiadomo\u015bci w strumieniach s\u0105 mapami\n                    for m_data in dict(messages)[stream_name]:\n                        last_msg, payload = m_data\n                        try:\n                            await websocket.send_text(\n                                model_cls(**decode_stream_message(payload)).json()\n                            )\n                        except ConnectionClosedOK:\n                            active = False\n                        except RuntimeError:\n                            active = False\n                        except ValidationError as e:\n                            raise ValueError(model_cls.schema()) from e\n\n            try:\n                await websocket.close()\n            except RuntimeError:\n                logger.info(\"WebSocket connection closed by client\")\n            else:\n                logger.info(\"WebSocket connection closed by server\")\n\n        api.schema.streams.append(\n            StreamInfo(\n                stream_name=cls.pybrook_options.stream_name,\n                websocket_path=f\"/{cls.pybrook_options.name}\",\n                report_schema=cls.pydantic_model.schema(),\n            )\n        )\n\n    @classmethod\n    def gen_consumers(cls, model: \"PyBrook\"):\n        inputs: dict[str, redis_plugin.Dependency] = {}\n        for field in cls._report_fields.values():\n            stream_key: str = field.source_field.stream_name\n            dep: redis_plugin.Dependency = inputs.setdefault(\n                stream_key, redis_plugin.Dependency(stream_key=stream_key)\n            )\n            dep.fields.append(\n                redis_plugin.DependencyField(\n                    src=field.source_field.field_name, dst=field.destination_field_name\n                )\n            )\n\n        model.add_dependency_resolver(\n            redis_plugin.DependencyResolver(\n                output_stream_key=cls.pybrook_options.stream_name,\n                inputs=list(inputs.values()),\n            )\n        )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.OutReport.gen_consumers","title":"<code>gen_consumers(model)</code>  <code>classmethod</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>@classmethod\ndef gen_consumers(cls, model: \"PyBrook\"):\n    inputs: dict[str, redis_plugin.Dependency] = {}\n    for field in cls._report_fields.values():\n        stream_key: str = field.source_field.stream_name\n        dep: redis_plugin.Dependency = inputs.setdefault(\n            stream_key, redis_plugin.Dependency(stream_key=stream_key)\n        )\n        dep.fields.append(\n            redis_plugin.DependencyField(\n                src=field.source_field.field_name, dst=field.destination_field_name\n            )\n        )\n\n    model.add_dependency_resolver(\n        redis_plugin.DependencyResolver(\n            output_stream_key=cls.pybrook_options.stream_name,\n            inputs=list(inputs.values()),\n        )\n    )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.OutReport.gen_routes","title":"<code>gen_routes(api, redis_dep)</code>  <code>classmethod</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>@classmethod\ndef gen_routes(  # noqa: WPS217, WPS231\n    cls, api: \"PyBrookApi\", redis_dep: aioredis.Redis\n):\n    model_cls = cls.pydantic_model\n\n    @api.fastapi.get(\n        f\"/{cls.pybrook_options.name}\",\n        response_model=model_cls,  # type: ignore\n        name=f\"Retrieve {cls.pybrook_options.name}\",\n    )\n    async def get_report(redis_conn: aioredis.Redis = redis_dep):\n        messages = await redis_conn.xrevrange(\n            cls.pybrook_options.stream_name, count=1\n        )\n        for _msg_id, msg_body in messages:  # noqa: WPS328\n            return model_cls(**decode_stream_message(msg_body))\n        return {}\n\n    @api.fastapi.websocket(f\"/{cls.pybrook_options.name}\")\n    async def read_reports(  # noqa: WPS231\n        websocket: fastapi.WebSocket, redis_conn: aioredis.Redis = redis_dep\n    ):\n        await websocket.accept()\n        last_msg = \"$\"\n        stream_name = cls.pybrook_options.stream_name\n        active = True\n        last_ping = time()\n        while active and api.fastapi.state.socket_active:\n            if time() - last_ping &gt; WEBSOCKET_PING_INTERVAL:\n                try:\n                    # Check if connection is active\n                    await asyncio.wait_for(\n                        websocket.receive_bytes(), timeout=WEBSOCKET_WAIT_TIME\n                    )\n                except asyncio.TimeoutError:\n                    ...  # Everything is OK\n                except (fastapi.WebSocketDisconnect, AssertionError):\n                    active = False\n                else:\n                    last_ping = time()\n            messages = await redis_conn.xread(\n                {stream_name: last_msg},\n                count=WEBSOCKET_XREAD_COUNT,\n                block=WEBSOCKET_XREAD_BLOCK,\n            )\n            if messages:\n                # Wiadomo\u015bci w strumieniach s\u0105 mapami\n                for m_data in dict(messages)[stream_name]:\n                    last_msg, payload = m_data\n                    try:\n                        await websocket.send_text(\n                            model_cls(**decode_stream_message(payload)).json()\n                        )\n                    except ConnectionClosedOK:\n                        active = False\n                    except RuntimeError:\n                        active = False\n                    except ValidationError as e:\n                        raise ValueError(model_cls.schema()) from e\n\n        try:\n            await websocket.close()\n        except RuntimeError:\n            logger.info(\"WebSocket connection closed by client\")\n        else:\n            logger.info(\"WebSocket connection closed by server\")\n\n    api.schema.streams.append(\n        StreamInfo(\n            stream_name=cls.pybrook_options.stream_name,\n            websocket_path=f\"/{cls.pybrook_options.name}\",\n            report_schema=cls.pydantic_model.schema(),\n        )\n    )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.OutReportMeta","title":"<code>OutReportMeta</code>","text":"<p>               Bases: <code>OptionsMixin[OutReportOptions]</code>, <code>type</code></p> Source code in <code>pybrook/models.py</code> <pre><code>class OutReportMeta(OptionsMixin[OutReportOptions], type):\n    _report_fields: Mapping[str, \"ReportField\"]\n    _model: type[pydantic.BaseModel]\n    pybrook_options: OutReportOptions\n\n    def __new__(mcs, name, bases, namespace):  # noqa: N804\n        \"\"\"\n        Initialize an [OutReport][pybrook.models.OutReport]\n        subclass by processing all of its ReportFields,\n        and initializing the\n        [pydantic_model][pybrook.models.OutReportMeta.pydantic_model]\n         property.\n        \"\"\"\n        cls = super().__new__(mcs, name, bases, namespace)  # noqa: WPS117\n        cls._report_fields = {}\n        for prop_name, report_field in inspect.getmembers(cls):\n            if isinstance(report_field, ReportField):\n                report_field.set_context(cls, prop_name)\n                cls._report_fields[prop_name] = report_field\n        pydantic_fields = {\n            rep_field.destination_field_name: (\n                rep_field.source_field.value_type,\n                pydantic.Field(),\n            )\n            for rep_field in cls._report_fields.values()  # type: ignore\n        }\n        pydantic_fields[MSG_ID_FIELD] = (\n            str,\n            pydantic.Field(\n                title=\"Message ID\",\n                description=(\n                    f\"Message id - {{object ID}}\"\n                    f\"{SPECIAL_CHAR}{{msg index for object}}\"\n                ),\n            ),\n        )\n        cls._model = pydantic.create_model(\n            cls.__name__ + \"Model\",\n            **pydantic_fields,  # type: ignore\n        )\n        return cls\n\n    @property\n    def stream_name(cls):\n        return cls.pybrook_options.stream_name\n\n    @property  # type: ignore\n    def pydantic_model(cls) -&gt; type[pydantic.BaseModel]:\n        \"\"\"\n        A Pydantic model describing the output report.\n        \"\"\"\n        pydantic_fields = {\n            report_field.destination_field_name: (\n                report_field.source_field.value_type,\n                pydantic.Field(),\n            )\n            for report_field in cls._report_fields.values()  # type: ignore\n        }\n        pydantic_fields[MSG_ID_FIELD] = (\n            str,\n            pydantic.Field(\n                title=\"Message ID\",\n                description=(\n                    f\"Message id - {{object ID}}\"\n                    f\"{SPECIAL_CHAR}{{msg index for object}}\"\n                ),\n            ),\n        )\n        if not hasattr(cls, \"_model\"):\n            cls._model: type[pydantic.BaseModel] = pydantic.create_model(\n                cls.__name__ + \"Model\",\n                **pydantic_fields,  # type: ignore\n            )\n        return cls._model\n\n    def _validate_options(cls, options: OutReportOptions) -&gt; OutReportOptions:\n        return options\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.OutReportMeta._model","title":"<code>_model: type[pydantic.BaseModel]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.OutReportMeta._report_fields","title":"<code>_report_fields: Mapping[str, ReportField]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.OutReportMeta.pybrook_options","title":"<code>pybrook_options: OutReportOptions</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.OutReportMeta.pydantic_model","title":"<code>pydantic_model: type[pydantic.BaseModel]</code>  <code>property</code>","text":"<p>A Pydantic model describing the output report.</p>"},{"location":"reference/pybrook/models.html#pybrook.models.OutReportMeta.stream_name","title":"<code>stream_name</code>  <code>property</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.OutReportMeta.__new__","title":"<code>__new__(mcs, name, bases, namespace)</code>","text":"<p>Initialize an OutReport subclass by processing all of its ReportFields, and initializing the pydantic_model  property.</p> Source code in <code>pybrook/models.py</code> <pre><code>def __new__(mcs, name, bases, namespace):  # noqa: N804\n    \"\"\"\n    Initialize an [OutReport][pybrook.models.OutReport]\n    subclass by processing all of its ReportFields,\n    and initializing the\n    [pydantic_model][pybrook.models.OutReportMeta.pydantic_model]\n     property.\n    \"\"\"\n    cls = super().__new__(mcs, name, bases, namespace)  # noqa: WPS117\n    cls._report_fields = {}\n    for prop_name, report_field in inspect.getmembers(cls):\n        if isinstance(report_field, ReportField):\n            report_field.set_context(cls, prop_name)\n            cls._report_fields[prop_name] = report_field\n    pydantic_fields = {\n        rep_field.destination_field_name: (\n            rep_field.source_field.value_type,\n            pydantic.Field(),\n        )\n        for rep_field in cls._report_fields.values()  # type: ignore\n    }\n    pydantic_fields[MSG_ID_FIELD] = (\n        str,\n        pydantic.Field(\n            title=\"Message ID\",\n            description=(\n                f\"Message id - {{object ID}}\"\n                f\"{SPECIAL_CHAR}{{msg index for object}}\"\n            ),\n        ),\n    )\n    cls._model = pydantic.create_model(\n        cls.__name__ + \"Model\",\n        **pydantic_fields,  # type: ignore\n    )\n    return cls\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.OutReportMeta._validate_options","title":"<code>_validate_options(options)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def _validate_options(cls, options: OutReportOptions) -&gt; OutReportOptions:\n    return options\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.OutReportOptions","title":"<code>OutReportOptions</code>  <code>dataclass</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>@dataclasses.dataclass\nclass OutReportOptions:\n    name: str\n\n    @property\n    def stream_name(self):\n        return f\"{SPECIAL_CHAR}{self.name}\"\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.OutReportOptions.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.OutReportOptions.stream_name","title":"<code>stream_name</code>  <code>property</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.OutReportOptions.__init__","title":"<code>__init__(name)</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook","title":"<code>PyBrook</code>","text":"<p>This class represents a PyBrook model.</p> Source code in <code>pybrook/models.py</code> <pre><code>class PyBrook:\n    \"\"\"This class represents a PyBrook model.\"\"\"\n\n    def __init__(self, redis_url: str, api_class: type[PyBrookApi] = PyBrookApi):\n        \"\"\"\n        Args:\n            redis_url: Url of the Redis Gears server.\n            api_class: API class - you can pass your own implementation of\n             [PyBrookApi][pybrook.models.PyBrookApi]\n             to modify the generated FastAPI app.\n        \"\"\"\n        self.inputs: dict[str, type[InReport]] = {}\n        self.outputs: dict[str, type[OutReport]] = {}\n        self.artificial_fields: dict[str, ArtificialField] = {}\n        self.consumers: list[BaseStreamConsumer] = []\n        self.redis_url: str = redis_url\n        self.api: PyBrookApi = api_class(self)\n        self.manager: Optional[WorkerManager] = None\n        self._redis_plugin_config: redis_plugin.BrookConfig = redis_plugin.BrookConfig()\n\n    def process_model(self) -&gt; None:\n        if not self.consumers:\n            report_classes: Iterable[type[ConsumerGenerator]] = [\n                *self.inputs.values(),\n                *self.outputs.values(),\n            ]\n            for report_class in report_classes:\n                report_class.gen_consumers(self)\n            for field in self.artificial_fields.values():\n                field.gen_consumers(self)\n\n    def add_input_tagger(self, tagger: redis_plugin.InputTagger):\n        self._redis_plugin_config.input_taggers[tagger.stream_key] = tagger\n\n    def add_dependency_resolver(self, resolver: redis_plugin.DependencyResolver):\n        self._redis_plugin_config.dependency_resolvers[resolver.output_stream_key] = (\n            resolver\n        )\n\n    @property\n    def app(self) -&gt; fastapi.FastAPI:\n        self.process_model()\n        return self.api.fastapi\n\n    def run(self, config: Optional[dict[str, ConsumerConfig]] = None):\n        \"\"\"\n        Runs the workers.\n\n        Args:\n            config: Consumer config, can be skipped - defaults\n                will be used.\n                See [pybrook.__main__][pybrook.__main__]\n                for details.\n        \"\"\"\n\n        config = config or {}\n        self.process_model()\n        self.manager = WorkerManager(\n            self.consumers,\n            consumer_config=config,\n            redis_plugin_config=self._redis_plugin_config,\n        )\n        self.manager.run()\n\n    def terminate(self):\n        \"\"\"Terminates all worker processes gracefully.\"\"\"\n        if not self.manager:\n            raise RuntimeError(\"PyBrook is not running!\")\n        self.manager.terminate()\n\n    def set_meta(\n        self,\n        *,\n        latitude_field: ReportField,\n        longitude_field: ReportField,\n        group_field: ReportField,\n        time_field: ReportField,\n        direction_field: Optional[ReportField] = None,\n    ):\n        \"\"\"Use this method to set metadata used by frontend.\"\"\"\n        self.api.schema.latitude_field = self._gen_field_info(latitude_field)\n        self.api.schema.longitude_field = self._gen_field_info(longitude_field)\n        self.api.schema.group_field = self._gen_field_info(group_field)\n        self.api.schema.time_field = self._gen_field_info(time_field)\n        if direction_field:\n            self.api.schema.direction_field = self._gen_field_info(direction_field)\n\n    def input(  # noqa: A003\n        self, name: Optional[str] = None, *, id_field: str\n    ) -&gt; Callable[[TI], TI]:\n        \"\"\"\n        Register an input report.\n\n        Returns:\n            A decorator, which accepts an InReport as an argument.\n        \"\"\"\n\n        def wrapper(cls):\n            name_safe = name or cls.__name__\n            self.inputs[name_safe] = cls\n            cls.pybrook_options = InReportOptions(id_field=id_field, name=name_safe)\n            self.api.visit(cls)\n            return cls\n\n        return wrapper\n\n    def output(self, name: Optional[str] = None) -&gt; Callable[[TO], TO]:\n        \"\"\"\n        Register an output report.\n\n        Returns:\n            A decorator, which accepts an OutReport as an argument.\n        \"\"\"\n\n        def wrapper(cls):\n            name_safe = name or cls.__name__\n            self.outputs[name_safe] = cls\n            cls.pybrook_options = OutReportOptions(name=name_safe)\n            self.api.visit(cls)\n            return cls\n\n        return wrapper\n\n    def artificial_field(self, name: Optional[str] = None) -&gt; Callable[[Callable], Any]:\n        \"\"\"\n        Register an artificial field.\n\n        Returns:\n            A decorator, which accepts a callable as an argument.\n            The callable provided is used to calculate\n            the value of the artificial field.\n        \"\"\"\n\n        def wrapper(fun: Callable) -&gt; Any:\n            field = ArtificialField(fun, name=name)\n            self.artificial_fields[name or fun.__name__] = field\n            field.on_registered(self)\n            return field\n\n        return wrapper\n\n    def add_consumer(self, consumer: BaseStreamConsumer):\n        \"\"\"\n        This is used by consumer generators.\n\n        For now it just adds a new consumer to the consumer list.\n        \"\"\"\n\n        self.consumers.append(consumer)\n\n    def _gen_field_info(self, field: ReportField) -&gt; FieldInfo:\n        return FieldInfo(\n            stream_name=field.destination_stream_name,\n            field_name=field.destination_field_name,\n        )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook._redis_plugin_config","title":"<code>_redis_plugin_config: redis_plugin.BrookConfig = redis_plugin.BrookConfig()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.api","title":"<code>api: PyBrookApi = api_class(self)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.app","title":"<code>app: fastapi.FastAPI</code>  <code>property</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.artificial_fields","title":"<code>artificial_fields: dict[str, ArtificialField] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.consumers","title":"<code>consumers: list[BaseStreamConsumer] = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.inputs","title":"<code>inputs: dict[str, type[InReport]] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.manager","title":"<code>manager: Optional[WorkerManager] = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.outputs","title":"<code>outputs: dict[str, type[OutReport]] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.redis_url","title":"<code>redis_url: str = redis_url</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.__init__","title":"<code>__init__(redis_url, api_class=PyBrookApi)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>redis_url</code> <code>str</code> <p>Url of the Redis Gears server.</p> required <code>api_class</code> <code>type[PyBrookApi]</code> <p>API class - you can pass your own implementation of PyBrookApi to modify the generated FastAPI app.</p> <code>PyBrookApi</code> Source code in <code>pybrook/models.py</code> <pre><code>def __init__(self, redis_url: str, api_class: type[PyBrookApi] = PyBrookApi):\n    \"\"\"\n    Args:\n        redis_url: Url of the Redis Gears server.\n        api_class: API class - you can pass your own implementation of\n         [PyBrookApi][pybrook.models.PyBrookApi]\n         to modify the generated FastAPI app.\n    \"\"\"\n    self.inputs: dict[str, type[InReport]] = {}\n    self.outputs: dict[str, type[OutReport]] = {}\n    self.artificial_fields: dict[str, ArtificialField] = {}\n    self.consumers: list[BaseStreamConsumer] = []\n    self.redis_url: str = redis_url\n    self.api: PyBrookApi = api_class(self)\n    self.manager: Optional[WorkerManager] = None\n    self._redis_plugin_config: redis_plugin.BrookConfig = redis_plugin.BrookConfig()\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook._gen_field_info","title":"<code>_gen_field_info(field)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def _gen_field_info(self, field: ReportField) -&gt; FieldInfo:\n    return FieldInfo(\n        stream_name=field.destination_stream_name,\n        field_name=field.destination_field_name,\n    )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.add_consumer","title":"<code>add_consumer(consumer)</code>","text":"<p>This is used by consumer generators.</p> <p>For now it just adds a new consumer to the consumer list.</p> Source code in <code>pybrook/models.py</code> <pre><code>def add_consumer(self, consumer: BaseStreamConsumer):\n    \"\"\"\n    This is used by consumer generators.\n\n    For now it just adds a new consumer to the consumer list.\n    \"\"\"\n\n    self.consumers.append(consumer)\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.add_dependency_resolver","title":"<code>add_dependency_resolver(resolver)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def add_dependency_resolver(self, resolver: redis_plugin.DependencyResolver):\n    self._redis_plugin_config.dependency_resolvers[resolver.output_stream_key] = (\n        resolver\n    )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.add_input_tagger","title":"<code>add_input_tagger(tagger)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def add_input_tagger(self, tagger: redis_plugin.InputTagger):\n    self._redis_plugin_config.input_taggers[tagger.stream_key] = tagger\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.artificial_field","title":"<code>artificial_field(name=None)</code>","text":"<p>Register an artificial field.</p> <p>Returns:</p> Type Description <code>Callable[[Callable], Any]</code> <p>A decorator, which accepts a callable as an argument.</p> <code>Callable[[Callable], Any]</code> <p>The callable provided is used to calculate</p> <code>Callable[[Callable], Any]</code> <p>the value of the artificial field.</p> Source code in <code>pybrook/models.py</code> <pre><code>def artificial_field(self, name: Optional[str] = None) -&gt; Callable[[Callable], Any]:\n    \"\"\"\n    Register an artificial field.\n\n    Returns:\n        A decorator, which accepts a callable as an argument.\n        The callable provided is used to calculate\n        the value of the artificial field.\n    \"\"\"\n\n    def wrapper(fun: Callable) -&gt; Any:\n        field = ArtificialField(fun, name=name)\n        self.artificial_fields[name or fun.__name__] = field\n        field.on_registered(self)\n        return field\n\n    return wrapper\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.input","title":"<code>input(name=None, *, id_field)</code>","text":"<p>Register an input report.</p> <p>Returns:</p> Type Description <code>Callable[[TI], TI]</code> <p>A decorator, which accepts an InReport as an argument.</p> Source code in <code>pybrook/models.py</code> <pre><code>def input(  # noqa: A003\n    self, name: Optional[str] = None, *, id_field: str\n) -&gt; Callable[[TI], TI]:\n    \"\"\"\n    Register an input report.\n\n    Returns:\n        A decorator, which accepts an InReport as an argument.\n    \"\"\"\n\n    def wrapper(cls):\n        name_safe = name or cls.__name__\n        self.inputs[name_safe] = cls\n        cls.pybrook_options = InReportOptions(id_field=id_field, name=name_safe)\n        self.api.visit(cls)\n        return cls\n\n    return wrapper\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.output","title":"<code>output(name=None)</code>","text":"<p>Register an output report.</p> <p>Returns:</p> Type Description <code>Callable[[TO], TO]</code> <p>A decorator, which accepts an OutReport as an argument.</p> Source code in <code>pybrook/models.py</code> <pre><code>def output(self, name: Optional[str] = None) -&gt; Callable[[TO], TO]:\n    \"\"\"\n    Register an output report.\n\n    Returns:\n        A decorator, which accepts an OutReport as an argument.\n    \"\"\"\n\n    def wrapper(cls):\n        name_safe = name or cls.__name__\n        self.outputs[name_safe] = cls\n        cls.pybrook_options = OutReportOptions(name=name_safe)\n        self.api.visit(cls)\n        return cls\n\n    return wrapper\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.process_model","title":"<code>process_model()</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def process_model(self) -&gt; None:\n    if not self.consumers:\n        report_classes: Iterable[type[ConsumerGenerator]] = [\n            *self.inputs.values(),\n            *self.outputs.values(),\n        ]\n        for report_class in report_classes:\n            report_class.gen_consumers(self)\n        for field in self.artificial_fields.values():\n            field.gen_consumers(self)\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.run","title":"<code>run(config=None)</code>","text":"<p>Runs the workers.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[dict[str, ConsumerConfig]]</code> <p>Consumer config, can be skipped - defaults will be used. See pybrook.main for details.</p> <code>None</code> Source code in <code>pybrook/models.py</code> <pre><code>def run(self, config: Optional[dict[str, ConsumerConfig]] = None):\n    \"\"\"\n    Runs the workers.\n\n    Args:\n        config: Consumer config, can be skipped - defaults\n            will be used.\n            See [pybrook.__main__][pybrook.__main__]\n            for details.\n    \"\"\"\n\n    config = config or {}\n    self.process_model()\n    self.manager = WorkerManager(\n        self.consumers,\n        consumer_config=config,\n        redis_plugin_config=self._redis_plugin_config,\n    )\n    self.manager.run()\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.set_meta","title":"<code>set_meta(*, latitude_field, longitude_field, group_field, time_field, direction_field=None)</code>","text":"<p>Use this method to set metadata used by frontend.</p> Source code in <code>pybrook/models.py</code> <pre><code>def set_meta(\n    self,\n    *,\n    latitude_field: ReportField,\n    longitude_field: ReportField,\n    group_field: ReportField,\n    time_field: ReportField,\n    direction_field: Optional[ReportField] = None,\n):\n    \"\"\"Use this method to set metadata used by frontend.\"\"\"\n    self.api.schema.latitude_field = self._gen_field_info(latitude_field)\n    self.api.schema.longitude_field = self._gen_field_info(longitude_field)\n    self.api.schema.group_field = self._gen_field_info(group_field)\n    self.api.schema.time_field = self._gen_field_info(time_field)\n    if direction_field:\n        self.api.schema.direction_field = self._gen_field_info(direction_field)\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrook.terminate","title":"<code>terminate()</code>","text":"<p>Terminates all worker processes gracefully.</p> Source code in <code>pybrook/models.py</code> <pre><code>def terminate(self):\n    \"\"\"Terminates all worker processes gracefully.\"\"\"\n    if not self.manager:\n        raise RuntimeError(\"PyBrook is not running!\")\n    self.manager.terminate()\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrookApi","title":"<code>PyBrookApi</code>","text":"<p>Represents the HTTP API.</p> <p>The default implementation is based on FastAPI.</p> Source code in <code>pybrook/models.py</code> <pre><code>class PyBrookApi:\n    \"\"\"\n    Represents the HTTP API.\n\n    The default implementation is based on FastAPI.\n    \"\"\"\n\n    def __init__(self, brook: \"PyBrook\"):\n        self.fastapi = fastapi.FastAPI()\n        self.brook = brook\n        self.schema = PyBrookSchema()\n        self.fastapi.add_middleware(\n            CORSMiddleware,\n            allow_credentials=True,\n            allow_origins=[\"*\"],\n            allow_methods=[\"*\"],\n            allow_headers=[\"*\"],\n        )\n\n        @self.fastapi.get(\"/pybrook-schema.json\", response_model=PyBrookSchema)\n        def get_schema():\n            return self.schema\n\n        @self.fastapi.on_event(\"startup\")\n        async def startup():\n            frontend_dir = str(Path(__file__).parent / \"frontend\")\n            self.fastapi.mount(\n                \"/panel/\", StaticFiles(directory=frontend_dir, html=True), name=\"static\"\n            )\n            self.fastapi.state.redis = await aioredis.from_url(\n                self.brook.redis_url, encoding=\"utf-8\", decode_responses=True\n            )\n            self.fastapi.state.socket_active = True\n            signal.signal(signal.SIGINT, shutdown)\n            signal.signal(signal.SIGTERM, shutdown)\n\n        @self.fastapi.on_event(\"shutdown\")\n        def shutdown(*args):\n            logger.info(\"set socket active to false\")\n            self.fastapi.state.socket_active = False\n            asyncio.create_task(self.fastapi.state.redis.close())  # noqa: WPS219\n            asyncio.create_task(\n                self.fastapi.state.redis.connection_pool.  # noqa: WPS219\n                disconnect()\n            )\n\n    async def redis_dependency(self) -&gt; AsyncIterator[aioredis.Redis]:\n        \"\"\"\n        Redis FastAPI Dependency\n\n        Yields:\n            A Redis connection\n        \"\"\"\n        yield self.fastapi.state.redis\n\n    def visit(self, generator: RouteGenerator):\n        \"\"\"Visits a route generator to add new endpoints.\"\"\"\n        generator.gen_routes(self, redis_dep=fastapi.Depends(self.redis_dependency))\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrookApi.brook","title":"<code>brook = brook</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.PyBrookApi.fastapi","title":"<code>fastapi = fastapi.FastAPI()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.PyBrookApi.schema","title":"<code>schema = PyBrookSchema()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.PyBrookApi.__init__","title":"<code>__init__(brook)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __init__(self, brook: \"PyBrook\"):\n    self.fastapi = fastapi.FastAPI()\n    self.brook = brook\n    self.schema = PyBrookSchema()\n    self.fastapi.add_middleware(\n        CORSMiddleware,\n        allow_credentials=True,\n        allow_origins=[\"*\"],\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n    @self.fastapi.get(\"/pybrook-schema.json\", response_model=PyBrookSchema)\n    def get_schema():\n        return self.schema\n\n    @self.fastapi.on_event(\"startup\")\n    async def startup():\n        frontend_dir = str(Path(__file__).parent / \"frontend\")\n        self.fastapi.mount(\n            \"/panel/\", StaticFiles(directory=frontend_dir, html=True), name=\"static\"\n        )\n        self.fastapi.state.redis = await aioredis.from_url(\n            self.brook.redis_url, encoding=\"utf-8\", decode_responses=True\n        )\n        self.fastapi.state.socket_active = True\n        signal.signal(signal.SIGINT, shutdown)\n        signal.signal(signal.SIGTERM, shutdown)\n\n    @self.fastapi.on_event(\"shutdown\")\n    def shutdown(*args):\n        logger.info(\"set socket active to false\")\n        self.fastapi.state.socket_active = False\n        asyncio.create_task(self.fastapi.state.redis.close())  # noqa: WPS219\n        asyncio.create_task(\n            self.fastapi.state.redis.connection_pool.  # noqa: WPS219\n            disconnect()\n        )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrookApi.redis_dependency","title":"<code>redis_dependency()</code>  <code>async</code>","text":"<p>Redis FastAPI Dependency</p> <p>Yields:</p> Type Description <code>AsyncIterator[Redis]</code> <p>A Redis connection</p> Source code in <code>pybrook/models.py</code> <pre><code>async def redis_dependency(self) -&gt; AsyncIterator[aioredis.Redis]:\n    \"\"\"\n    Redis FastAPI Dependency\n\n    Yields:\n        A Redis connection\n    \"\"\"\n    yield self.fastapi.state.redis\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.PyBrookApi.visit","title":"<code>visit(generator)</code>","text":"<p>Visits a route generator to add new endpoints.</p> Source code in <code>pybrook/models.py</code> <pre><code>def visit(self, generator: RouteGenerator):\n    \"\"\"Visits a route generator to add new endpoints.\"\"\"\n    generator.gen_routes(self, redis_dep=fastapi.Depends(self.redis_dependency))\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.Registrable","title":"<code>Registrable</code>","text":"<p>An interface describing objects that need to perform some tasks, after the initial processing stage is completed.</p> <p>This is used to solve issues like circular (recursive) references.</p> Source code in <code>pybrook/models.py</code> <pre><code>class Registrable:\n    \"\"\"\n    An interface describing objects that need to\n    perform some tasks, after the initial\n    processing stage is completed.\n\n    This is used to solve issues like circular (recursive) references.\n    \"\"\"\n\n    def on_registered(self, model: \"PyBrook\"):\n        \"\"\"\n        Used mostly to evaluate lazy stuff.\n\n        Args:\n            model: The model to register at.\n\n        Raises:\n            NotImplementedError: When used directly.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.Registrable.on_registered","title":"<code>on_registered(model)</code>","text":"<p>Used mostly to evaluate lazy stuff.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>PyBrook</code> <p>The model to register at.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>When used directly.</p> Source code in <code>pybrook/models.py</code> <pre><code>def on_registered(self, model: \"PyBrook\"):\n    \"\"\"\n    Used mostly to evaluate lazy stuff.\n\n    Args:\n        model: The model to register at.\n\n    Raises:\n        NotImplementedError: When used directly.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.ReportField","title":"<code>ReportField</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>class ReportField:\n    def __init__(self, source_field: Union[SourceField, Any]):\n        if not isinstance(source_field, SourceField):\n            raise RuntimeError(f\"{source_field} is not a SourceField\")\n        self.destination_field_name: str\n        self.source_field = source_field\n        self.owner: type[OutReport]\n\n    def __repr__(self):\n        return (\n            f\"&lt;{self.__class__.__name__} \"\n            f\"destination_field_name='{self.destination_field_name}' \"\n            f\"source_field={self.source_field} \"\n            f\"owner={self.owner}&gt;\"\n        )\n\n    @property\n    def destination_stream_name(self):\n        return self.owner.stream_name\n\n    def set_context(self, owner: type[\"OutReport\"], name: str):\n        self.owner = owner\n        self.destination_field_name = name\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.ReportField.destination_field_name","title":"<code>destination_field_name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.ReportField.destination_stream_name","title":"<code>destination_stream_name</code>  <code>property</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.ReportField.owner","title":"<code>owner: type[OutReport]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.ReportField.source_field","title":"<code>source_field = source_field</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.ReportField.__init__","title":"<code>__init__(source_field)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __init__(self, source_field: Union[SourceField, Any]):\n    if not isinstance(source_field, SourceField):\n        raise RuntimeError(f\"{source_field} is not a SourceField\")\n    self.destination_field_name: str\n    self.source_field = source_field\n    self.owner: type[OutReport]\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.ReportField.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __repr__(self):\n    return (\n        f\"&lt;{self.__class__.__name__} \"\n        f\"destination_field_name='{self.destination_field_name}' \"\n        f\"source_field={self.source_field} \"\n        f\"owner={self.owner}&gt;\"\n    )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.ReportField.set_context","title":"<code>set_context(owner, name)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def set_context(self, owner: type[\"OutReport\"], name: str):\n    self.owner = owner\n    self.destination_field_name = name\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.RouteGenerator","title":"<code>RouteGenerator</code>","text":"<p>An interface describing objects that can generate API endpoints.</p> Source code in <code>pybrook/models.py</code> <pre><code>class RouteGenerator:\n    \"\"\"\n    An interface describing objects that can generate API endpoints.\n    \"\"\"\n\n    @classmethod\n    def gen_routes(cls, api: \"PyBrookApi\", redis_dep: aioredis.Redis):\n        \"\"\"\n        Implementations of this method should add API endpoints\n        to the [PyBrookApi][pybrook.models.PyBrookApi] instance passed as `api`.\n\n        Args:\n            api: The PyBrookApi instance processed.\n            redis_dep: FastAPI redis dependency.\n\n        Raises:\n            NotImplementedError: When used directly.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.RouteGenerator.gen_routes","title":"<code>gen_routes(api, redis_dep)</code>  <code>classmethod</code>","text":"<p>Implementations of this method should add API endpoints to the PyBrookApi instance passed as <code>api</code>.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>PyBrookApi</code> <p>The PyBrookApi instance processed.</p> required <code>redis_dep</code> <code>Redis</code> <p>FastAPI redis dependency.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>When used directly.</p> Source code in <code>pybrook/models.py</code> <pre><code>@classmethod\ndef gen_routes(cls, api: \"PyBrookApi\", redis_dep: aioredis.Redis):\n    \"\"\"\n    Implementations of this method should add API endpoints\n    to the [PyBrookApi][pybrook.models.PyBrookApi] instance passed as `api`.\n\n    Args:\n        api: The PyBrookApi instance processed.\n        redis_dep: FastAPI redis dependency.\n\n    Raises:\n        NotImplementedError: When used directly.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.SourceField","title":"<code>SourceField</code>","text":"<p>A base class for fields (InputField, ArtificialField)</p> <p>Provides metadata used to generate producers &amp; consumers.</p> Source code in <code>pybrook/models.py</code> <pre><code>class SourceField:\n    \"\"\"\n    A base class for fields\n    ([InputField][pybrook.models.InputField],\n    [ArtificialField][pybrook.models.ArtificialField])\n\n    Provides metadata used to generate producers &amp; consumers.\n    \"\"\"\n\n    def __init__(\n        self, field_name: str, *, value_type: type,\n        source_obj: Optional[type[\"InReport\"]] = None\n    ):\n        \"\"\"\n        Args:\n            value_type: Field value type.\n            field_name: Source field.\n            source_obj: InReport that the field belongs to.\n        \"\"\"\n        self.field_name: str = field_name\n        self.source_obj: Optional[type[InReport]] = source_obj\n        self._value_type: type = value_type\n\n    @property\n    def value_type(self):\n        \"\"\"Value type of the source field.\"\"\"\n        return self._value_type\n\n    @property  # type: ignore\n    def stream_name(self) -&gt; str:\n        if self.source_obj:\n            return f\"{SPECIAL_CHAR}{self.source_obj.pybrook_options.name}\"\n        return f\"{SPECIAL_CHAR}artificial{SPECIAL_CHAR}{self.field_name}\"\n\n    def __repr__(self):\n        return (\n            f'&lt;{self.__class__.__name__} name={self.field_name},'\n            f' report_class={\n                self.source_obj.__name__ \n                if self.source_obj else\n                \"artificial\"\n            },'\n            f' value_type={self.value_type.__name__}&gt;'\n        )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.SourceField._value_type","title":"<code>_value_type: type = value_type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.SourceField.field_name","title":"<code>field_name: str = field_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.SourceField.source_obj","title":"<code>source_obj: Optional[type[InReport]] = source_obj</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.SourceField.stream_name","title":"<code>stream_name: str</code>  <code>property</code>","text":""},{"location":"reference/pybrook/models.html#pybrook.models.SourceField.value_type","title":"<code>value_type</code>  <code>property</code>","text":"<p>Value type of the source field.</p>"},{"location":"reference/pybrook/models.html#pybrook.models.SourceField.__init__","title":"<code>__init__(field_name, *, value_type, source_obj=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>value_type</code> <code>type</code> <p>Field value type.</p> required <code>field_name</code> <code>str</code> <p>Source field.</p> required <code>source_obj</code> <code>Optional[type[InReport]]</code> <p>InReport that the field belongs to.</p> <code>None</code> Source code in <code>pybrook/models.py</code> <pre><code>def __init__(\n    self, field_name: str, *, value_type: type,\n    source_obj: Optional[type[\"InReport\"]] = None\n):\n    \"\"\"\n    Args:\n        value_type: Field value type.\n        field_name: Source field.\n        source_obj: InReport that the field belongs to.\n    \"\"\"\n    self.field_name: str = field_name\n    self.source_obj: Optional[type[InReport]] = source_obj\n    self._value_type: type = value_type\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.SourceField.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __repr__(self):\n    return (\n        f'&lt;{self.__class__.__name__} name={self.field_name},'\n        f' report_class={\n            self.source_obj.__name__ \n            if self.source_obj else\n            \"artificial\"\n        },'\n        f' value_type={self.value_type.__name__}&gt;'\n    )\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.dependency","title":"<code>dependency(src)</code>","text":"<p>Depending on <code>src</code>, the injected dependency will be value of some field (artificial or loaded from report) or a Redis instance.</p> <p>See Dependency for implementation details.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>DTYPE</code> <p>Target of the dependency.  Should be an instance of SourceField  or a Redis class (<code>aioredis.Redis</code> or <code>redis.Redis</code>).</p> required <p>Returns:      A HistoricalDependency,      but mypy is made to believe that the type      the returned value is      src.value_type.</p> Source code in <code>pybrook/models.py</code> <pre><code>def dependency(src: DTYPE) -&gt; DTYPE:\n    \"\"\"\n    Depending on `src`, the injected dependency\n    will be value of some field (artificial\n    or loaded from report) or a Redis instance.\n\n    See [Dependency][pybrook.models.Dependency] for implementation details.\n\n    Args:\n        src: Target of the dependency.\n             Should be an instance of [SourceField][pybrook.models.SourceField]\n             or a Redis class (`aioredis.Redis` or `redis.Redis`).\n    Returns:\n         A [HistoricalDependency][pybrook.models.HistoricalDependency],\n         but mypy is made to believe that the type\n         the returned value is\n         [src.value_type][pybrook.models.SourceField.value_type].\n    \"\"\"\n    dep: DTYPE\n    dep = Dependency(src)  # type: ignore\n    return dep  # noqa: WPS331\n</code></pre>"},{"location":"reference/pybrook/models.html#pybrook.models.historical_dependency","title":"<code>historical_dependency(src, history_length)</code>","text":"<p>See HistoricalDependency for implementation details.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>DTYPE</code> <p>Target of the dependency.  Should be an instance of SourceField.  You can also reference artificial fields by passing their name,  which is useful for recursive dependencies.</p> required <p>Returns:     A HistoricalDependency,     but mypy is made to believe that it's a sequence containing items     of type of the corresponding SourceField.</p> Source code in <code>pybrook/models.py</code> <pre><code>def historical_dependency(src: DTYPE, history_length: int) -&gt; Sequence[DTYPE]:\n    \"\"\"\n    See [HistoricalDependency][pybrook.models.HistoricalDependency]\n    for implementation details.\n\n    Args:\n        src: Target of the dependency.\n             Should be an instance of [SourceField][pybrook.models.SourceField].\n             You can also reference artificial fields by passing their name,\n             which is useful for recursive dependencies.\n    Returns:\n        A [HistoricalDependency][pybrook.models.HistoricalDependency],\n        but mypy is made to believe that it's a sequence containing items\n        of type of the corresponding [SourceField][pybrook.models.SourceField].\n    \"\"\"\n    dep: Sequence[DTYPE]\n    dep = HistoricalDependency(  # type: ignore\n        src,  # type: ignore\n        history_length=history_length,\n    )\n    return dep  # noqa: WPS331\n</code></pre>"},{"location":"reference/pybrook/redis_plugin_integration.html","title":"<code>pybrook.redis_plugin_integration</code>","text":""},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.BrookConfig","title":"<code>BrookConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pybrook/redis_plugin_integration.py</code> <pre><code>class BrookConfig(BaseModel):\n    dependency_resolvers: dict[str, DependencyResolver] = {}\n    input_taggers: dict[str, InputTagger] = {}\n</code></pre>"},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.BrookConfig.dependency_resolvers","title":"<code>dependency_resolvers: dict[str, DependencyResolver] = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.BrookConfig.input_taggers","title":"<code>input_taggers: dict[str, InputTagger] = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.Dependency","title":"<code>Dependency</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pybrook/redis_plugin_integration.py</code> <pre><code>class Dependency(BaseModel):\n    stream_key: str\n    fields: list[DependencyField | HistoricalDependencyField] = []\n</code></pre>"},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.Dependency.fields","title":"<code>fields: list[DependencyField | HistoricalDependencyField] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.Dependency.stream_key","title":"<code>stream_key: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.DependencyField","title":"<code>DependencyField</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pybrook/redis_plugin_integration.py</code> <pre><code>class DependencyField(BaseModel):\n    type: Literal[\"Regular\"] = \"Regular\"\n    src: str\n    dst: str\n</code></pre>"},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.DependencyField.dst","title":"<code>dst: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.DependencyField.src","title":"<code>src: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.DependencyField.type","title":"<code>type: Literal['Regular'] = 'Regular'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.DependencyResolver","title":"<code>DependencyResolver</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pybrook/redis_plugin_integration.py</code> <pre><code>class DependencyResolver(BaseModel):\n    inputs: list[Dependency] = []\n    output_stream_key: str\n</code></pre>"},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.DependencyResolver.inputs","title":"<code>inputs: list[Dependency] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.DependencyResolver.output_stream_key","title":"<code>output_stream_key: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.HistoricalDependencyField","title":"<code>HistoricalDependencyField</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pybrook/redis_plugin_integration.py</code> <pre><code>class HistoricalDependencyField(BaseModel):\n    type: Literal[\"Historical\"] = \"Historical\"\n    src: str\n    dst: str\n    history_len: int\n</code></pre>"},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.HistoricalDependencyField.dst","title":"<code>dst: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.HistoricalDependencyField.history_len","title":"<code>history_len: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.HistoricalDependencyField.src","title":"<code>src: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.HistoricalDependencyField.type","title":"<code>type: Literal['Historical'] = 'Historical'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.InputTagger","title":"<code>InputTagger</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pybrook/redis_plugin_integration.py</code> <pre><code>class InputTagger(BaseModel):\n    stream_key: str\n    obj_id_field: str\n</code></pre>"},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.InputTagger.obj_id_field","title":"<code>obj_id_field: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/redis_plugin_integration.html#pybrook.redis_plugin_integration.InputTagger.stream_key","title":"<code>stream_key: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/schemas.html","title":"<code>pybrook.schemas</code>","text":"<p>This module contains definitions of Pydantic models used to tell the frontend about available streams &amp; fields.</p> <p>This is required, because the OpenAPI documentation doesn't support WebSockets.</p>"},{"location":"reference/pybrook/schemas.html#pybrook.schemas.FieldInfo","title":"<code>FieldInfo</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pybrook/schemas.py</code> <pre><code>class FieldInfo(BaseModel):\n    stream_name: str\n    field_name: str\n</code></pre>"},{"location":"reference/pybrook/schemas.html#pybrook.schemas.FieldInfo.field_name","title":"<code>field_name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/schemas.html#pybrook.schemas.FieldInfo.stream_name","title":"<code>stream_name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/schemas.html#pybrook.schemas.PyBrookSchema","title":"<code>PyBrookSchema</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pybrook/schemas.py</code> <pre><code>class PyBrookSchema(BaseModel):\n    streams: list[StreamInfo] = []\n    special_char: str = SPECIAL_CHAR\n    msg_id_field: str = MSG_ID_FIELD\n    latitude_field: Optional[FieldInfo] = None\n    longitude_field: Optional[FieldInfo] = None\n    time_field: Optional[FieldInfo] = None\n    group_field: Optional[FieldInfo] = None\n    direction_field: Optional[FieldInfo] = None\n</code></pre>"},{"location":"reference/pybrook/schemas.html#pybrook.schemas.PyBrookSchema.direction_field","title":"<code>direction_field: Optional[FieldInfo] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/schemas.html#pybrook.schemas.PyBrookSchema.group_field","title":"<code>group_field: Optional[FieldInfo] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/schemas.html#pybrook.schemas.PyBrookSchema.latitude_field","title":"<code>latitude_field: Optional[FieldInfo] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/schemas.html#pybrook.schemas.PyBrookSchema.longitude_field","title":"<code>longitude_field: Optional[FieldInfo] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/schemas.html#pybrook.schemas.PyBrookSchema.msg_id_field","title":"<code>msg_id_field: str = MSG_ID_FIELD</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/schemas.html#pybrook.schemas.PyBrookSchema.special_char","title":"<code>special_char: str = SPECIAL_CHAR</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/schemas.html#pybrook.schemas.PyBrookSchema.streams","title":"<code>streams: list[StreamInfo] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/schemas.html#pybrook.schemas.PyBrookSchema.time_field","title":"<code>time_field: Optional[FieldInfo] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/schemas.html#pybrook.schemas.StreamInfo","title":"<code>StreamInfo</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pybrook/schemas.py</code> <pre><code>class StreamInfo(BaseModel):\n    stream_name: str\n    websocket_path: str\n    report_schema: dict[Any, Any]\n</code></pre>"},{"location":"reference/pybrook/schemas.html#pybrook.schemas.StreamInfo.report_schema","title":"<code>report_schema: dict[Any, Any]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/schemas.html#pybrook.schemas.StreamInfo.stream_name","title":"<code>stream_name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/schemas.html#pybrook.schemas.StreamInfo.websocket_path","title":"<code>websocket_path: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/__init__.html","title":"<code>pybrook.consumers</code>","text":""},{"location":"reference/pybrook/consumers/base.html","title":"<code>pybrook.consumers.base</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.CONSUMER_NAME_LENGTH","title":"<code>CONSUMER_NAME_LENGTH = 64</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.AsyncStreamConsumer","title":"<code>AsyncStreamConsumer</code>","text":"<p>               Bases: <code>BaseStreamConsumer</code></p> Source code in <code>pybrook/consumers/base.py</code> <pre><code>class AsyncStreamConsumer(BaseStreamConsumer):\n    async def process_message_async(\n        self,\n        stream_name: str,\n        message: dict[str, str],\n        *,\n        redis_conn: aioredis.Redis,\n        pipeline: aioredis.client.Pipeline,\n    ) -&gt; dict[str, dict[str, str]]:\n        raise NotImplementedError(  # pragma: nocover\n            f\"Async version of process_message \"\n            f\"for {type(self).__name__} not implemented.\"\n        )\n\n    @property\n    def supported_impl(self) -&gt; set[ConsumerImpl]:\n        return super().supported_impl | {ConsumerImpl.ASYNC}\n\n    def stop(self, signum=None, frame=None):\n        super().stop(signum, frame)\n        if asyncio.all_tasks():\n            logger.info(\n                \"Waiting for all asyncio tasks to finish, use Ctrl + C to force exit.\"\n            )\n\n    async def run_async(self) -&gt; None:  # noqa: WPS231\n        self.register_signals()\n        redis_conn: aioredis.Redis = await aioredis.from_url(\n            self.redis_url, encoding=\"utf-8\", decode_responses=True\n        )\n        self.active = True\n        xreadgroup_params = self._xreadgroup_params\n        tasks: set[asyncio.Future] = set()\n        while self.active:\n            response = await redis_conn.xreadgroup(**xreadgroup_params)\n            for stream, messages in response:\n                for msg_id, payload in messages:\n                    tasks.add(\n                        asyncio.create_task(\n                            self._handle_message_async(\n                                stream, msg_id, payload, redis_conn\n                            )\n                        )\n                    )\n            for num, task in enumerate(asyncio.as_completed(tasks)):\n                await task\n                if num &gt; self._read_chunk_length / 2 or not self.active:\n                    done, tasks = await asyncio.wait(\n                        tasks, return_when=asyncio.FIRST_COMPLETED\n                    )\n                    xreadgroup_params[\"count\"] = self._read_chunk_length - len(tasks)\n                    break\n        await redis_conn.close()\n\n    async def _handle_message_async(\n        self,\n        stream: str,\n        msg_id: str,\n        payload: dict[str, str],\n        redis_conn: aioredis.Redis,\n    ):\n        async with redis_conn.pipeline() as p:\n            result = await self.process_message_async(\n                stream, payload, redis_conn=redis_conn, pipeline=p\n            )\n            for out_stream, out_msg in result.items():\n                p.xadd(out_stream, out_msg)  # type: ignore\n            p.xack(stream, self.consumer_group_name, msg_id)\n            try:\n                await p.execute()\n            except aioredis.WatchError:  # pragma: nocover\n                await redis_conn.xack(stream, self.consumer_group_name, msg_id)\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.AsyncStreamConsumer.supported_impl","title":"<code>supported_impl: set[ConsumerImpl]</code>  <code>property</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.AsyncStreamConsumer._handle_message_async","title":"<code>_handle_message_async(stream, msg_id, payload, redis_conn)</code>  <code>async</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>async def _handle_message_async(\n    self,\n    stream: str,\n    msg_id: str,\n    payload: dict[str, str],\n    redis_conn: aioredis.Redis,\n):\n    async with redis_conn.pipeline() as p:\n        result = await self.process_message_async(\n            stream, payload, redis_conn=redis_conn, pipeline=p\n        )\n        for out_stream, out_msg in result.items():\n            p.xadd(out_stream, out_msg)  # type: ignore\n        p.xack(stream, self.consumer_group_name, msg_id)\n        try:\n            await p.execute()\n        except aioredis.WatchError:  # pragma: nocover\n            await redis_conn.xack(stream, self.consumer_group_name, msg_id)\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.AsyncStreamConsumer.process_message_async","title":"<code>process_message_async(stream_name, message, *, redis_conn, pipeline)</code>  <code>async</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>async def process_message_async(\n    self,\n    stream_name: str,\n    message: dict[str, str],\n    *,\n    redis_conn: aioredis.Redis,\n    pipeline: aioredis.client.Pipeline,\n) -&gt; dict[str, dict[str, str]]:\n    raise NotImplementedError(  # pragma: nocover\n        f\"Async version of process_message \"\n        f\"for {type(self).__name__} not implemented.\"\n    )\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.AsyncStreamConsumer.run_async","title":"<code>run_async()</code>  <code>async</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>async def run_async(self) -&gt; None:  # noqa: WPS231\n    self.register_signals()\n    redis_conn: aioredis.Redis = await aioredis.from_url(\n        self.redis_url, encoding=\"utf-8\", decode_responses=True\n    )\n    self.active = True\n    xreadgroup_params = self._xreadgroup_params\n    tasks: set[asyncio.Future] = set()\n    while self.active:\n        response = await redis_conn.xreadgroup(**xreadgroup_params)\n        for stream, messages in response:\n            for msg_id, payload in messages:\n                tasks.add(\n                    asyncio.create_task(\n                        self._handle_message_async(\n                            stream, msg_id, payload, redis_conn\n                        )\n                    )\n                )\n        for num, task in enumerate(asyncio.as_completed(tasks)):\n            await task\n            if num &gt; self._read_chunk_length / 2 or not self.active:\n                done, tasks = await asyncio.wait(\n                    tasks, return_when=asyncio.FIRST_COMPLETED\n                )\n                xreadgroup_params[\"count\"] = self._read_chunk_length - len(tasks)\n                break\n    await redis_conn.close()\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.AsyncStreamConsumer.stop","title":"<code>stop(signum=None, frame=None)</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def stop(self, signum=None, frame=None):\n    super().stop(signum, frame)\n    if asyncio.all_tasks():\n        logger.info(\n            \"Waiting for all asyncio tasks to finish, use Ctrl + C to force exit.\"\n        )\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer","title":"<code>BaseStreamConsumer</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>class BaseStreamConsumer:\n    def __init__(\n        self,\n        *,\n        redis_url: str,\n        consumer_group_name: str,\n        input_streams: Iterable[str],\n        use_thread_executor: bool = False,\n        read_chunk_length: int = 1,\n        read_messages_since: Union[str, int] = \"$\",\n    ):\n        self.consumer_group_name = consumer_group_name\n        self.redis_url = redis_url\n        self._active = False\n        self._use_thread_executor = use_thread_executor\n        self._read_chunk_length = read_chunk_length\n        self.executor = None\n        self.input_streams = tuple(input_streams)\n        if not re.match(r\"\\$|\\d+(?:-\\d+)?\", str(read_messages_since)):\n            raise ValueError(\"read_messages_since should be a positive integer or $!\")\n        self.read_messages_since = str(read_messages_since)\n\n    @property\n    def supported_impl(self) -&gt; set[ConsumerImpl]:\n        return set()  # pragma: nocover\n\n    def __repr__(self):\n        return f\"&lt;{self.__class__.__name__} input_streams={self.input_streams}&gt;\"\n\n    @property\n    def input_streams(self) -&gt; tuple[str, ...]:\n        return tuple(self._input_streams)\n\n    @input_streams.setter\n    def input_streams(self, streams: tuple[str, ...]):\n        self._input_streams = tuple(streams)\n\n    def register_consumer(self):\n        redis_conn = redis.from_url(\n            self.redis_url, encoding=\"utf-8\", decode_responses=True\n        )\n        for stream in self.input_streams:\n            try:\n                redis_conn.xgroup_create(\n                    stream,\n                    self.consumer_group_name,\n                    id=self.read_messages_since,\n                    mkstream=True,\n                )\n            except redis.ResponseError as e:\n                if \"BUSYGROUP\" not in str(e):\n                    raise e  # pragma: nocover\n\n    def stop(self, signum=None, frame=None):\n        if not self._active:\n            logger.warning(f\"Killing {self}\")\n            sys.exit()\n        logger.info(f\"Terminating {self}\")\n        self.active = False\n\n    def register_signals(self):\n        signal.signal(signal.SIGTERM, self.stop)\n        signal.signal(signal.SIGINT, self.stop)\n\n    @property\n    def active(self):\n        return self._active\n\n    @active.setter\n    def active(self, value: bool):\n        self._active = value\n\n    @property\n    def _xreadgroup_params(self) -&gt; MutableMapping:\n        consumer_name = secrets.token_urlsafe(CONSUMER_NAME_LENGTH)\n        return {\n            \"streams\": {s: \"&gt;\" for s in self.input_streams},\n            \"groupname\": self.consumer_group_name,\n            \"consumername\": consumer_name,\n            \"count\": self._read_chunk_length,\n            \"block\": 1000,\n        }\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer._active","title":"<code>_active = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer._read_chunk_length","title":"<code>_read_chunk_length = read_chunk_length</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer._use_thread_executor","title":"<code>_use_thread_executor = use_thread_executor</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer._xreadgroup_params","title":"<code>_xreadgroup_params: MutableMapping</code>  <code>property</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.active","title":"<code>active</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.consumer_group_name","title":"<code>consumer_group_name = consumer_group_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.executor","title":"<code>executor = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.input_streams","title":"<code>input_streams: tuple[str, ...]</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.read_messages_since","title":"<code>read_messages_since = str(read_messages_since)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.redis_url","title":"<code>redis_url = redis_url</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.supported_impl","title":"<code>supported_impl: set[ConsumerImpl]</code>  <code>property</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.__init__","title":"<code>__init__(*, redis_url, consumer_group_name, input_streams, use_thread_executor=False, read_chunk_length=1, read_messages_since='$')</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def __init__(\n    self,\n    *,\n    redis_url: str,\n    consumer_group_name: str,\n    input_streams: Iterable[str],\n    use_thread_executor: bool = False,\n    read_chunk_length: int = 1,\n    read_messages_since: Union[str, int] = \"$\",\n):\n    self.consumer_group_name = consumer_group_name\n    self.redis_url = redis_url\n    self._active = False\n    self._use_thread_executor = use_thread_executor\n    self._read_chunk_length = read_chunk_length\n    self.executor = None\n    self.input_streams = tuple(input_streams)\n    if not re.match(r\"\\$|\\d+(?:-\\d+)?\", str(read_messages_since)):\n        raise ValueError(\"read_messages_since should be a positive integer or $!\")\n    self.read_messages_since = str(read_messages_since)\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def __repr__(self):\n    return f\"&lt;{self.__class__.__name__} input_streams={self.input_streams}&gt;\"\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.register_consumer","title":"<code>register_consumer()</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def register_consumer(self):\n    redis_conn = redis.from_url(\n        self.redis_url, encoding=\"utf-8\", decode_responses=True\n    )\n    for stream in self.input_streams:\n        try:\n            redis_conn.xgroup_create(\n                stream,\n                self.consumer_group_name,\n                id=self.read_messages_since,\n                mkstream=True,\n            )\n        except redis.ResponseError as e:\n            if \"BUSYGROUP\" not in str(e):\n                raise e  # pragma: nocover\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.register_signals","title":"<code>register_signals()</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def register_signals(self):\n    signal.signal(signal.SIGTERM, self.stop)\n    signal.signal(signal.SIGINT, self.stop)\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.stop","title":"<code>stop(signum=None, frame=None)</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def stop(self, signum=None, frame=None):\n    if not self._active:\n        logger.warning(f\"Killing {self}\")\n        sys.exit()\n    logger.info(f\"Terminating {self}\")\n    self.active = False\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.ConsumerImpl","title":"<code>ConsumerImpl</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>pybrook/consumers/base.py</code> <pre><code>class ConsumerImpl(Enum):\n    ASYNC = \"ASYNC\"\n    SYNC = \"SYNC\"\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.ConsumerImpl.ASYNC","title":"<code>ASYNC = 'ASYNC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.ConsumerImpl.SYNC","title":"<code>SYNC = 'SYNC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.SyncStreamConsumer","title":"<code>SyncStreamConsumer</code>","text":"<p>               Bases: <code>BaseStreamConsumer</code></p> Source code in <code>pybrook/consumers/base.py</code> <pre><code>class SyncStreamConsumer(BaseStreamConsumer):\n    def process_message_sync(\n        self,\n        stream_name: str,\n        message: dict[str, str],\n        *,\n        redis_conn: redis.Redis,\n        pipeline: redis.client.Pipeline,\n    ) -&gt; dict[str, dict[str, str]]:\n        raise NotImplementedError(  # pragma: nocover\n            f\"Sync version of process_message\"\n            f\" for {type(self).__name__} not implemented.\"\n        )\n\n    @property\n    def supported_impl(self) -&gt; set[ConsumerImpl]:\n        return super().supported_impl | {ConsumerImpl.SYNC}\n\n    def stop(self, signum=None, frame=None):\n        super().stop(signum, frame)\n        if not self.executor:\n            return\n        self.executor.shutdown(wait=False, cancel_futures=False)\n        if self.executor._work_queue.qsize():  # noqa: WPS437\n            logger.warning(\n                \"Waiting for all futures to finish, use Ctrl + C to force exit.\"\n            )\n\n    def run_sync(self) -&gt; None:  # noqa: WPS231\n        self.register_signals()\n        redis_conn: redis.Redis = redis.from_url(\n            self.redis_url, encoding=\"utf-8\", decode_responses=True\n        )\n        self._active = True\n        xreadgroup_params = self._xreadgroup_params\n        if self._use_thread_executor:\n            self.executor = futures.ThreadPoolExecutor(\n                max_workers=self._read_chunk_length\n            )  # TODO: Parametrize max_workers\n        tasks: set[futures.Future] = set()\n        while self.active:\n            response = redis_conn.xreadgroup(**xreadgroup_params)\n            for stream, messages in response:\n                for msg_id, payload in messages:\n                    if self._use_thread_executor:\n                        tasks.add(\n                            self.executor.submit( # type: ignore[union-attr]\n                                self._handle_message_sync,\n                                stream,\n                                msg_id,\n                                payload,\n                                redis_conn,\n                            )\n                        )\n                    else:\n                        self._handle_message_sync(stream, msg_id, payload, redis_conn)\n                if self._use_thread_executor:\n                    for num, task in enumerate(futures.as_completed(tasks)):\n                        task.result()\n                        if num &gt; self._read_chunk_length / 2 or not self.active:\n                            done, tasks = futures.wait(\n                                tasks, return_when=asyncio.FIRST_COMPLETED\n                            )\n                            xreadgroup_params[\"count\"] = self._read_chunk_length - len(\n                                tasks\n                            )\n                            break\n        redis_conn.close()\n\n    def _handle_message_sync(\n        self, stream: str, msg_id: str, payload: dict[str, str], redis_conn: redis.Redis\n    ):\n        with redis_conn.pipeline() as p:\n            result = self.process_message_sync(\n                stream, payload, redis_conn=redis_conn, pipeline=p\n            )\n            for out_stream, out_msg in result.items():\n                p.xadd(out_stream, out_msg)\n            p.xack(stream, self.consumer_group_name, msg_id)\n            try:\n                p.execute()\n            except redis.WatchError:  # pragma: nocover\n                redis_conn.xack(stream, self.consumer_group_name, msg_id)\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.SyncStreamConsumer.supported_impl","title":"<code>supported_impl: set[ConsumerImpl]</code>  <code>property</code>","text":""},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.SyncStreamConsumer._handle_message_sync","title":"<code>_handle_message_sync(stream, msg_id, payload, redis_conn)</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def _handle_message_sync(\n    self, stream: str, msg_id: str, payload: dict[str, str], redis_conn: redis.Redis\n):\n    with redis_conn.pipeline() as p:\n        result = self.process_message_sync(\n            stream, payload, redis_conn=redis_conn, pipeline=p\n        )\n        for out_stream, out_msg in result.items():\n            p.xadd(out_stream, out_msg)\n        p.xack(stream, self.consumer_group_name, msg_id)\n        try:\n            p.execute()\n        except redis.WatchError:  # pragma: nocover\n            redis_conn.xack(stream, self.consumer_group_name, msg_id)\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.SyncStreamConsumer.process_message_sync","title":"<code>process_message_sync(stream_name, message, *, redis_conn, pipeline)</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def process_message_sync(\n    self,\n    stream_name: str,\n    message: dict[str, str],\n    *,\n    redis_conn: redis.Redis,\n    pipeline: redis.client.Pipeline,\n) -&gt; dict[str, dict[str, str]]:\n    raise NotImplementedError(  # pragma: nocover\n        f\"Sync version of process_message\"\n        f\" for {type(self).__name__} not implemented.\"\n    )\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.SyncStreamConsumer.run_sync","title":"<code>run_sync()</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def run_sync(self) -&gt; None:  # noqa: WPS231\n    self.register_signals()\n    redis_conn: redis.Redis = redis.from_url(\n        self.redis_url, encoding=\"utf-8\", decode_responses=True\n    )\n    self._active = True\n    xreadgroup_params = self._xreadgroup_params\n    if self._use_thread_executor:\n        self.executor = futures.ThreadPoolExecutor(\n            max_workers=self._read_chunk_length\n        )  # TODO: Parametrize max_workers\n    tasks: set[futures.Future] = set()\n    while self.active:\n        response = redis_conn.xreadgroup(**xreadgroup_params)\n        for stream, messages in response:\n            for msg_id, payload in messages:\n                if self._use_thread_executor:\n                    tasks.add(\n                        self.executor.submit( # type: ignore[union-attr]\n                            self._handle_message_sync,\n                            stream,\n                            msg_id,\n                            payload,\n                            redis_conn,\n                        )\n                    )\n                else:\n                    self._handle_message_sync(stream, msg_id, payload, redis_conn)\n            if self._use_thread_executor:\n                for num, task in enumerate(futures.as_completed(tasks)):\n                    task.result()\n                    if num &gt; self._read_chunk_length / 2 or not self.active:\n                        done, tasks = futures.wait(\n                            tasks, return_when=asyncio.FIRST_COMPLETED\n                        )\n                        xreadgroup_params[\"count\"] = self._read_chunk_length - len(\n                            tasks\n                        )\n                        break\n    redis_conn.close()\n</code></pre>"},{"location":"reference/pybrook/consumers/base.html#pybrook.consumers.base.SyncStreamConsumer.stop","title":"<code>stop(signum=None, frame=None)</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def stop(self, signum=None, frame=None):\n    super().stop(signum, frame)\n    if not self.executor:\n        return\n    self.executor.shutdown(wait=False, cancel_futures=False)\n    if self.executor._work_queue.qsize():  # noqa: WPS437\n        logger.warning(\n            \"Waiting for all futures to finish, use Ctrl + C to force exit.\"\n        )\n</code></pre>"},{"location":"reference/pybrook/consumers/field_generator.html","title":"<code>pybrook.consumers.field_generator</code>","text":""},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.AnyRedis","title":"<code>AnyRedis = Union[aioredis.Redis, redis.Redis]</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.AsyncFieldGenerator","title":"<code>AsyncFieldGenerator</code>","text":"<p>               Bases: <code>AsyncStreamConsumer</code>, <code>BaseFieldGenerator</code></p> Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>class AsyncFieldGenerator(AsyncStreamConsumer, BaseFieldGenerator):\n    async def process_message_async(\n        self,\n        stream_name: str,\n        message: dict[str, str],\n        *,\n        redis_conn: aioredis.Redis,\n        pipeline: aioredis.client.Pipeline,\n    ) -&gt; dict[str, dict[str, str]]:\n        message = decode_stream_message(message)\n        message_id = message.pop(MSG_ID_FIELD)\n        try:\n            dependencies = self.dep_model(**message).dict()\n        except ValidationError as e:\n            raise e\n        value = await self.call_generator(dependencies, redis_conn)\n        return {\n            self.output_stream_name: encode_stream_message(\n                {MSG_ID_FIELD: message_id, self.field_name: value}\n            )\n        }\n</code></pre>"},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.AsyncFieldGenerator.process_message_async","title":"<code>process_message_async(stream_name, message, *, redis_conn, pipeline)</code>  <code>async</code>","text":"Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>async def process_message_async(\n    self,\n    stream_name: str,\n    message: dict[str, str],\n    *,\n    redis_conn: aioredis.Redis,\n    pipeline: aioredis.client.Pipeline,\n) -&gt; dict[str, dict[str, str]]:\n    message = decode_stream_message(message)\n    message_id = message.pop(MSG_ID_FIELD)\n    try:\n        dependencies = self.dep_model(**message).dict()\n    except ValidationError as e:\n        raise e\n    value = await self.call_generator(dependencies, redis_conn)\n    return {\n        self.output_stream_name: encode_stream_message(\n            {MSG_ID_FIELD: message_id, self.field_name: value}\n        )\n    }\n</code></pre>"},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator","title":"<code>BaseFieldGenerator</code>","text":"<p>               Bases: <code>BaseStreamConsumer</code></p> Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>class BaseFieldGenerator(BaseStreamConsumer):\n    @dataclasses.dataclass\n    class Dep:  # noqa: WPS431\n        name: str\n        value_type: type\n\n    def __init__(\n        self,\n        *,\n        generator: Callable,\n        redis_url: str,\n        field_name: str,\n        namespace: str = ARTIFICIAL_NAMESPACE,\n        dependency_stream: str,\n        dependencies: list[Dep],\n        redis_deps: Optional[list[str]] = None,\n        read_chunk_length: int = 200,\n        **kwargs,\n    ):\n        self.generator = generator\n        self.field_name = field_name\n        self.redis_deps = redis_deps or []\n        self.output_stream_name = f\"{SPECIAL_CHAR}{namespace}{SPECIAL_CHAR}{field_name}\"\n        pydantic_fields = {\n            dep.name: (dep.value_type, pydantic.Field()) for dep in dependencies\n        }\n        self.dep_model: type[pydantic.BaseModel] = pydantic.create_model(\n            field_name + \"Model\",\n            **pydantic_fields,  # type: ignore\n        )\n\n        super().__init__(\n            redis_url=redis_url,\n            use_thread_executor=True,\n            consumer_group_name=f\"{field_name}{SPECIAL_CHAR}fg\",\n            input_streams=[dependency_stream],\n            read_chunk_length=read_chunk_length,\n            **kwargs,\n        )\n\n    def __repr__(self):\n        return f\"&lt;{self.__class__.__name__} input_streams={self.input_streams}&gt;\"\n\n    def call_generator(self, dependencies, redis_conn: AnyRedis):\n        if self.redis_deps:\n            return self.generator(\n                **dependencies, **{k: redis_conn for k in self.redis_deps}\n            )\n        return self.generator(**dependencies)\n</code></pre>"},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.dep_model","title":"<code>dep_model: type[pydantic.BaseModel] = pydantic.create_model(field_name + 'Model', **pydantic_fields)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.field_name","title":"<code>field_name = field_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.generator","title":"<code>generator = generator</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.output_stream_name","title":"<code>output_stream_name = f'{SPECIAL_CHAR}{namespace}{SPECIAL_CHAR}{field_name}'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.redis_deps","title":"<code>redis_deps = redis_deps or []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.Dep","title":"<code>Dep</code>  <code>dataclass</code>","text":"Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>@dataclasses.dataclass\nclass Dep:  # noqa: WPS431\n    name: str\n    value_type: type\n</code></pre>"},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.Dep.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.Dep.value_type","title":"<code>value_type: type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.Dep.__init__","title":"<code>__init__(name, value_type)</code>","text":""},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.__init__","title":"<code>__init__(*, generator, redis_url, field_name, namespace=ARTIFICIAL_NAMESPACE, dependency_stream, dependencies, redis_deps=None, read_chunk_length=200, **kwargs)</code>","text":"Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>def __init__(\n    self,\n    *,\n    generator: Callable,\n    redis_url: str,\n    field_name: str,\n    namespace: str = ARTIFICIAL_NAMESPACE,\n    dependency_stream: str,\n    dependencies: list[Dep],\n    redis_deps: Optional[list[str]] = None,\n    read_chunk_length: int = 200,\n    **kwargs,\n):\n    self.generator = generator\n    self.field_name = field_name\n    self.redis_deps = redis_deps or []\n    self.output_stream_name = f\"{SPECIAL_CHAR}{namespace}{SPECIAL_CHAR}{field_name}\"\n    pydantic_fields = {\n        dep.name: (dep.value_type, pydantic.Field()) for dep in dependencies\n    }\n    self.dep_model: type[pydantic.BaseModel] = pydantic.create_model(\n        field_name + \"Model\",\n        **pydantic_fields,  # type: ignore\n    )\n\n    super().__init__(\n        redis_url=redis_url,\n        use_thread_executor=True,\n        consumer_group_name=f\"{field_name}{SPECIAL_CHAR}fg\",\n        input_streams=[dependency_stream],\n        read_chunk_length=read_chunk_length,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>def __repr__(self):\n    return f\"&lt;{self.__class__.__name__} input_streams={self.input_streams}&gt;\"\n</code></pre>"},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.call_generator","title":"<code>call_generator(dependencies, redis_conn)</code>","text":"Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>def call_generator(self, dependencies, redis_conn: AnyRedis):\n    if self.redis_deps:\n        return self.generator(\n            **dependencies, **{k: redis_conn for k in self.redis_deps}\n        )\n    return self.generator(**dependencies)\n</code></pre>"},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.SyncFieldGenerator","title":"<code>SyncFieldGenerator</code>","text":"<p>               Bases: <code>SyncStreamConsumer</code>, <code>BaseFieldGenerator</code></p> Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>class SyncFieldGenerator(SyncStreamConsumer, BaseFieldGenerator):\n    def process_message_sync(\n        self,\n        stream_name: str,\n        message: dict[str, str],\n        *,\n        redis_conn: redis.Redis,\n        pipeline: redis.client.Pipeline,\n    ) -&gt; dict[str, dict[str, str]]:\n        message = decode_stream_message(message)\n        message_id = message.pop(MSG_ID_FIELD)\n        try:\n            dependencies = self.dep_model(**message).dict()\n        except ValidationError as e:\n            raise e\n        value = self.call_generator(dependencies, redis_conn)\n        return {\n            self.output_stream_name: encode_stream_message(\n                {MSG_ID_FIELD: message_id, self.field_name: value}\n            )\n        }\n</code></pre>"},{"location":"reference/pybrook/consumers/field_generator.html#pybrook.consumers.field_generator.SyncFieldGenerator.process_message_sync","title":"<code>process_message_sync(stream_name, message, *, redis_conn, pipeline)</code>","text":"Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>def process_message_sync(\n    self,\n    stream_name: str,\n    message: dict[str, str],\n    *,\n    redis_conn: redis.Redis,\n    pipeline: redis.client.Pipeline,\n) -&gt; dict[str, dict[str, str]]:\n    message = decode_stream_message(message)\n    message_id = message.pop(MSG_ID_FIELD)\n    try:\n        dependencies = self.dep_model(**message).dict()\n    except ValidationError as e:\n        raise e\n    value = self.call_generator(dependencies, redis_conn)\n    return {\n        self.output_stream_name: encode_stream_message(\n            {MSG_ID_FIELD: message_id, self.field_name: value}\n        )\n    }\n</code></pre>"},{"location":"reference/pybrook/consumers/worker.html","title":"<code>pybrook.consumers.worker</code>","text":""},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.DEFAULT_PROCESSES_NUM","title":"<code>DEFAULT_PROCESSES_NUM = multiprocessing.cpu_count()</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.ConsumerConfig","title":"<code>ConsumerConfig</code>  <code>dataclass</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>@dataclasses.dataclass\nclass ConsumerConfig:\n    workers: int = DEFAULT_WORKERS\n</code></pre>"},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.ConsumerConfig.workers","title":"<code>workers: int = DEFAULT_WORKERS</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.ConsumerConfig.__init__","title":"<code>__init__(workers=DEFAULT_WORKERS)</code>","text":""},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.Worker","title":"<code>Worker</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>class Worker:\n    def __init__(self, consumer: BaseStreamConsumer):\n        self._consumer = consumer\n\n    def run(self, *, processes_num: int = DEFAULT_PROCESSES_NUM):\n        if isinstance(self._consumer, SyncStreamConsumer):\n            return self._spawn_sync(processes_num=processes_num)\n        elif isinstance(self._consumer, AsyncStreamConsumer):\n            return self._spawn_async(processes_num=processes_num)\n        raise NotImplementedError(self._consumer)\n\n    def _spawn_sync(self, processes_num: int) -&gt; Iterable[multiprocessing.Process]:\n        return self._spawn(\n            target=self._consumer.run_sync,  # type: ignore\n            processes_num=processes_num,\n        )\n\n    def _async_wrapper(self):\n        policy = uvloop.EventLoopPolicy()\n        asyncio.set_event_loop_policy(policy)\n        asyncio.set_event_loop(policy.new_event_loop())\n        try:\n            asyncio.get_event_loop().run_until_complete(self._consumer.run_async())\n        except KeyboardInterrupt:\n            ...\n        except asyncio.CancelledError:\n            ...  # This is fine, shouldn't break anything\n\n    def _spawn_async(self, *, processes_num: int) -&gt; Iterable[multiprocessing.Process]:\n        return self._spawn(target=self._async_wrapper, processes_num=processes_num)\n\n    def _spawn(\n        self,\n        *,\n        target: Callable,\n        processes_num: int,\n        args: tuple[Any, ...] = (),\n    ) -&gt; Iterable[multiprocessing.Process]:\n        processes = []\n        self._consumer.register_consumer()\n\n        for _ in range(processes_num):\n            proc = multiprocessing.Process(target=target, args=args)\n            proc.start()\n            processes.append(proc)\n        logger.info(\n            f\"Spawned {processes_num} processes for {type(self._consumer).__name__}\"\n        )\n        return processes\n</code></pre>"},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.Worker._consumer","title":"<code>_consumer = consumer</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.Worker.__init__","title":"<code>__init__(consumer)</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def __init__(self, consumer: BaseStreamConsumer):\n    self._consumer = consumer\n</code></pre>"},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.Worker._async_wrapper","title":"<code>_async_wrapper()</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def _async_wrapper(self):\n    policy = uvloop.EventLoopPolicy()\n    asyncio.set_event_loop_policy(policy)\n    asyncio.set_event_loop(policy.new_event_loop())\n    try:\n        asyncio.get_event_loop().run_until_complete(self._consumer.run_async())\n    except KeyboardInterrupt:\n        ...\n    except asyncio.CancelledError:\n        ...  # This is fine, shouldn't break anything\n</code></pre>"},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.Worker._spawn","title":"<code>_spawn(*, target, processes_num, args=())</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def _spawn(\n    self,\n    *,\n    target: Callable,\n    processes_num: int,\n    args: tuple[Any, ...] = (),\n) -&gt; Iterable[multiprocessing.Process]:\n    processes = []\n    self._consumer.register_consumer()\n\n    for _ in range(processes_num):\n        proc = multiprocessing.Process(target=target, args=args)\n        proc.start()\n        processes.append(proc)\n    logger.info(\n        f\"Spawned {processes_num} processes for {type(self._consumer).__name__}\"\n    )\n    return processes\n</code></pre>"},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.Worker._spawn_async","title":"<code>_spawn_async(*, processes_num)</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def _spawn_async(self, *, processes_num: int) -&gt; Iterable[multiprocessing.Process]:\n    return self._spawn(target=self._async_wrapper, processes_num=processes_num)\n</code></pre>"},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.Worker._spawn_sync","title":"<code>_spawn_sync(processes_num)</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def _spawn_sync(self, processes_num: int) -&gt; Iterable[multiprocessing.Process]:\n    return self._spawn(\n        target=self._consumer.run_sync,  # type: ignore\n        processes_num=processes_num,\n    )\n</code></pre>"},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.Worker.run","title":"<code>run(*, processes_num=DEFAULT_PROCESSES_NUM)</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def run(self, *, processes_num: int = DEFAULT_PROCESSES_NUM):\n    if isinstance(self._consumer, SyncStreamConsumer):\n        return self._spawn_sync(processes_num=processes_num)\n    elif isinstance(self._consumer, AsyncStreamConsumer):\n        return self._spawn_async(processes_num=processes_num)\n    raise NotImplementedError(self._consumer)\n</code></pre>"},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.WorkerManager","title":"<code>WorkerManager</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>class WorkerManager:\n    def __init__(\n        self,\n        consumers: Iterable[BaseStreamConsumer],\n        redis_plugin_config: BrookConfig,\n        consumer_config: Optional[dict[str, ConsumerConfig]] = None,\n        enable_gears: bool = True,\n    ):\n        self.consumers = consumers\n        self.config = consumer_config or {}\n        self.redis_urls: set[str] = {c.redis_url for c in consumers}\n        self.redis_plugin_config: BrookConfig = redis_plugin_config\n        self.regular_consumers: list[BaseStreamConsumer] = list(consumers)\n        self.processes: list[multiprocessing.Process] = []\n        self._kill_on_terminate = False\n\n    def terminate(self):\n        if self._kill_on_terminate:\n            for p in self.processes:\n                p.kill()\n            return\n        for p in self.processes:  # noqa: WPS440\n            p.terminate()\n        self._kill_on_terminate = True\n\n    @logger.catch()\n    def run(self) -&gt; None:\n        if self.processes:\n            raise RuntimeError(\"Already running!\")\n        signal.signal(signal.SIGINT, lambda *args: self.terminate)\n        signal.signal(signal.SIGTERM, lambda *args: self.terminate)\n\n        self.spawn_workers()\n\n        for redis_url in self.redis_urls:\n            redis_conn: redis.Redis = redis.from_url(\n                redis_url, decode_responses=True, encoding=\"utf-8\"\n            )\n            # TODO: REGISTER PYBROOK CONFIG HERE\n            redis_conn.execute_command(\"PB.SETCONFIG\", self.redis_plugin_config.json())\n\n        for proc in self.processes:\n            with suppress(KeyboardInterrupt):\n                proc.join()\n        self.processes = []\n\n    def spawn_workers(self):\n        for c in self.regular_consumers:\n            consumer_config = self.config.get(c.consumer_group_name, ConsumerConfig())\n            logger.info(f\"Spawning worker for {c}...\")\n            w = Worker(c)\n            procs = w.run(processes_num=consumer_config.workers)\n            self.processes.extend(procs)\n</code></pre>"},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.WorkerManager._kill_on_terminate","title":"<code>_kill_on_terminate = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.WorkerManager.config","title":"<code>config = consumer_config or {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.WorkerManager.consumers","title":"<code>consumers = consumers</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.WorkerManager.processes","title":"<code>processes: list[multiprocessing.Process] = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.WorkerManager.redis_plugin_config","title":"<code>redis_plugin_config: BrookConfig = redis_plugin_config</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.WorkerManager.redis_urls","title":"<code>redis_urls: set[str] = {c.redis_url for c in consumers}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.WorkerManager.regular_consumers","title":"<code>regular_consumers: list[BaseStreamConsumer] = list(consumers)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.WorkerManager.__init__","title":"<code>__init__(consumers, redis_plugin_config, consumer_config=None, enable_gears=True)</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def __init__(\n    self,\n    consumers: Iterable[BaseStreamConsumer],\n    redis_plugin_config: BrookConfig,\n    consumer_config: Optional[dict[str, ConsumerConfig]] = None,\n    enable_gears: bool = True,\n):\n    self.consumers = consumers\n    self.config = consumer_config or {}\n    self.redis_urls: set[str] = {c.redis_url for c in consumers}\n    self.redis_plugin_config: BrookConfig = redis_plugin_config\n    self.regular_consumers: list[BaseStreamConsumer] = list(consumers)\n    self.processes: list[multiprocessing.Process] = []\n    self._kill_on_terminate = False\n</code></pre>"},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.WorkerManager.run","title":"<code>run()</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>@logger.catch()\ndef run(self) -&gt; None:\n    if self.processes:\n        raise RuntimeError(\"Already running!\")\n    signal.signal(signal.SIGINT, lambda *args: self.terminate)\n    signal.signal(signal.SIGTERM, lambda *args: self.terminate)\n\n    self.spawn_workers()\n\n    for redis_url in self.redis_urls:\n        redis_conn: redis.Redis = redis.from_url(\n            redis_url, decode_responses=True, encoding=\"utf-8\"\n        )\n        # TODO: REGISTER PYBROOK CONFIG HERE\n        redis_conn.execute_command(\"PB.SETCONFIG\", self.redis_plugin_config.json())\n\n    for proc in self.processes:\n        with suppress(KeyboardInterrupt):\n            proc.join()\n    self.processes = []\n</code></pre>"},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.WorkerManager.spawn_workers","title":"<code>spawn_workers()</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def spawn_workers(self):\n    for c in self.regular_consumers:\n        consumer_config = self.config.get(c.consumer_group_name, ConsumerConfig())\n        logger.info(f\"Spawning worker for {c}...\")\n        w = Worker(c)\n        procs = w.run(processes_num=consumer_config.workers)\n        self.processes.extend(procs)\n</code></pre>"},{"location":"reference/pybrook/consumers/worker.html#pybrook.consumers.worker.WorkerManager.terminate","title":"<code>terminate()</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def terminate(self):\n    if self._kill_on_terminate:\n        for p in self.processes:\n            p.kill()\n        return\n    for p in self.processes:  # noqa: WPS440\n        p.terminate()\n    self._kill_on_terminate = True\n</code></pre>"},{"location":"reference/pybrook/examples/__init__.html","title":"<code>pybrook.examples</code>","text":""},{"location":"reference/pybrook/examples/demo.html","title":"<code>pybrook.examples.demo</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.app","title":"<code>app = brook.app</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.brook","title":"<code>brook = PyBrook(environ.get('REDIS_URL', 'redis://localhost'))</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.BrigadeReport","title":"<code>BrigadeReport</code>","text":"<p>               Bases: <code>OutReport</code></p> Source code in <code>pybrook/examples/demo.py</code> <pre><code>@brook.output(\"brigade-report\")\nclass BrigadeReport(OutReport):\n    brigade = ReportField(ZTMReport.brigade)\n    time = ReportField(ZTMReport.time)\n</code></pre>"},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.BrigadeReport.brigade","title":"<code>brigade = ReportField(ZTMReport.brigade)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.BrigadeReport.time","title":"<code>time = ReportField(ZTMReport.time)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.DirectionReport","title":"<code>DirectionReport</code>","text":"<p>               Bases: <code>OutReport</code></p> Source code in <code>pybrook/examples/demo.py</code> <pre><code>@brook.output(\"direction-report\")\nclass DirectionReport(OutReport):\n    direction = ReportField(direction)\n    time = ReportField(ZTMReport.time)\n</code></pre>"},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.DirectionReport.direction","title":"<code>direction = ReportField(direction)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.DirectionReport.time","title":"<code>time = ReportField(ZTMReport.time)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.LocationReport","title":"<code>LocationReport</code>","text":"<p>               Bases: <code>OutReport</code></p> Source code in <code>pybrook/examples/demo.py</code> <pre><code>@brook.output(\"location-report\")\nclass LocationReport(OutReport):\n    vehicle_number = ReportField(ZTMReport.vehicle_number)\n    lat = ReportField(ZTMReport.lat)\n    lon = ReportField(ZTMReport.lon)\n    line = ReportField(ZTMReport.line)\n    time = ReportField(ZTMReport.time)\n    brigade = ReportField(ZTMReport.brigade)\n</code></pre>"},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.LocationReport.brigade","title":"<code>brigade = ReportField(ZTMReport.brigade)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.LocationReport.lat","title":"<code>lat = ReportField(ZTMReport.lat)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.LocationReport.line","title":"<code>line = ReportField(ZTMReport.line)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.LocationReport.lon","title":"<code>lon = ReportField(ZTMReport.lon)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.LocationReport.time","title":"<code>time = ReportField(ZTMReport.time)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.LocationReport.vehicle_number","title":"<code>vehicle_number = ReportField(ZTMReport.vehicle_number)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.ZTMReport","title":"<code>ZTMReport</code>","text":"<p>               Bases: <code>InReport</code></p> Source code in <code>pybrook/examples/demo.py</code> <pre><code>@brook.input(\"ztm-report\", id_field=\"vehicle_number\")\nclass ZTMReport(InReport):\n    vehicle_number: int\n    time: datetime\n    lat: float\n    lon: float\n    brigade: str\n    line: str\n</code></pre>"},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.ZTMReport.brigade","title":"<code>brigade: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.ZTMReport.lat","title":"<code>lat: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.ZTMReport.line","title":"<code>line: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.ZTMReport.lon","title":"<code>lon: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.ZTMReport.time","title":"<code>time: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.ZTMReport.vehicle_number","title":"<code>vehicle_number: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/demo.html#pybrook.examples.demo.direction","title":"<code>direction(lat_history=historical_dependency(ZTMReport.lat, history_length=1), lon_history=historical_dependency(ZTMReport.lon, history_length=1), lat=dependency(ZTMReport.lat), lon=dependency(ZTMReport.lon))</code>","text":"Source code in <code>pybrook/examples/demo.py</code> <pre><code>@brook.artificial_field()\ndef direction(\n    lat_history: Sequence[float] = historical_dependency(\n        ZTMReport.lat, history_length=1\n    ),\n    lon_history: Sequence[float] = historical_dependency(\n        ZTMReport.lon, history_length=1\n    ),\n    lat: float = dependency(ZTMReport.lat),\n    lon: float = dependency(ZTMReport.lon),\n) -&gt; Optional[float]:\n    (prev_lat,) = lat_history\n    (prev_lon,) = lon_history\n    if prev_lat and prev_lon:\n        return degrees(atan2(lon - prev_lon, lat - prev_lat))\n    return None\n</code></pre>"},{"location":"reference/pybrook/examples/ztm.html","title":"<code>pybrook.examples.ztm</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.app","title":"<code>app = brook.app</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.brook","title":"<code>brook = PyBrook('redis://localhost')</code>  <code>module-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.DirectionReport","title":"<code>DirectionReport</code>","text":"<p>               Bases: <code>OutReport</code></p> Source code in <code>pybrook/examples/ztm.py</code> <pre><code>@brook.output(\"direction-report\")\nclass DirectionReport(OutReport):\n    lat = ReportField(ZTMReport.lat)\n    long = ReportField(ZTMReport.lon)\n    direction = ReportField(direction)\n</code></pre>"},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.DirectionReport.direction","title":"<code>direction = ReportField(direction)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.DirectionReport.lat","title":"<code>lat = ReportField(ZTMReport.lat)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.DirectionReport.long","title":"<code>long = ReportField(ZTMReport.lon)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.LocationReport","title":"<code>LocationReport</code>","text":"<p>               Bases: <code>OutReport</code></p> Source code in <code>pybrook/examples/ztm.py</code> <pre><code>@brook.output(\"location-report\")\nclass LocationReport(OutReport):\n    vehicle_number = ReportField(ZTMReport.vehicle_number)\n    lat = ReportField(ZTMReport.lat)\n    lon = ReportField(ZTMReport.lon)\n    line = ReportField(ZTMReport.line)\n    time = ReportField(ZTMReport.time)\n    brigade = ReportField(ZTMReport.brigade)\n</code></pre>"},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.LocationReport.brigade","title":"<code>brigade = ReportField(ZTMReport.brigade)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.LocationReport.lat","title":"<code>lat = ReportField(ZTMReport.lat)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.LocationReport.line","title":"<code>line = ReportField(ZTMReport.line)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.LocationReport.lon","title":"<code>lon = ReportField(ZTMReport.lon)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.LocationReport.time","title":"<code>time = ReportField(ZTMReport.time)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.LocationReport.vehicle_number","title":"<code>vehicle_number = ReportField(ZTMReport.vehicle_number)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.ZTMReport","title":"<code>ZTMReport</code>","text":"<p>               Bases: <code>InReport</code></p> Source code in <code>pybrook/examples/ztm.py</code> <pre><code>@brook.input(\"ztm-report\", id_field=\"vehicle_number\")\nclass ZTMReport(InReport):\n    vehicle_number: int\n    time: datetime\n    lat: float\n    lon: float\n    brigade: str\n    line: str\n</code></pre>"},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.ZTMReport.brigade","title":"<code>brigade: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.ZTMReport.lat","title":"<code>lat: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.ZTMReport.line","title":"<code>line: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.ZTMReport.lon","title":"<code>lon: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.ZTMReport.time","title":"<code>time: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.ZTMReport.vehicle_number","title":"<code>vehicle_number: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pybrook/examples/ztm.html#pybrook.examples.ztm.direction","title":"<code>direction(lat_history=historical_dependency(ZTMReport.lat, history_length=1), lon_history=historical_dependency(ZTMReport.lon, history_length=1), lat=dependency(ZTMReport.lat), lon=dependency(ZTMReport.lon))</code>  <code>async</code>","text":"Source code in <code>pybrook/examples/ztm.py</code> <pre><code>@brook.artificial_field(\"direction\")\nasync def direction(\n    lat_history: Sequence[Optional[float]] = historical_dependency(\n        ZTMReport.lat, history_length=1\n    ),\n    lon_history: Sequence[Optional[float]] = historical_dependency(\n        ZTMReport.lon, history_length=1\n    ),\n    lat: float = dependency(ZTMReport.lat),\n    lon: float = dependency(ZTMReport.lon),\n) -&gt; Optional[float]:\n    (prev_lat,) = lat_history\n    (prev_lon,) = lon_history\n    if prev_lat and prev_lon:\n        return degrees(atan2(lon - prev_lon, lat - prev_lat))\n    return None\n</code></pre>"}]}